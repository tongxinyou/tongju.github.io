<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/tongju.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/tongju.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/tongju.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/tongju.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/tongju.github.io/css/main.css">


<link rel="stylesheet" href="/tongju.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"tongxinyou.github.io","root":"/tongju.github.io/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="个人技术成长之路">
<meta property="og:type" content="website">
<meta property="og:title" content="墨白的博客">
<meta property="og:url" content="https://tongxinyou.github.io/index.html">
<meta property="og:site_name" content="墨白的博客">
<meta property="og:description" content="个人技术成长之路">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="墨白">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://tongxinyou.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>墨白的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/tongju.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">墨白的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">个人技术成长之路</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/tongju.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/tongju.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tongxinyou.github.io/2022/11/08/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/tongju.github.io/images/avatar.gif">
      <meta itemprop="name" content="墨白">
      <meta itemprop="description" content="个人技术成长之路">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="墨白的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/tongju.github.io/2022/11/08/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/" class="post-title-link" itemprop="url">垃圾回收策略</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tongju.github.io/categories/JS/" itemprop="url" rel="index"><span itemprop="name">JS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="V8-的垃圾回收策略"><a href="#V8-的垃圾回收策略" class="headerlink" title="V8 的垃圾回收策略"></a>V8 的垃圾回收策略</h2><p>V8 的垃圾回收策略主要是基于<strong>分代式垃圾回收机制</strong>，其根据对象的存活时间将内存的垃圾回收进行不同的分代，然后对不同的分代采用不同的垃圾回收算法。</p>
<h3 id="V8-的内存结构"><a href="#V8-的内存结构" class="headerlink" title="V8 的内存结构"></a>V8 的内存结构</h3><ul>
<li>**新生代(new_space)**：大多数的对象开始都会被分配在这里，这个区域相对较小但是垃圾回收特别频繁，该区域被分为两半，一半用来分配内存，另一半用于在垃圾回收时将需要保留的对象复制过来。</li>
<li>**老生代(old_space)**：新生代中的对象在存活一段时间后就会被转移到老生代内存区，相对于新生代该内存区域的垃圾回收频率较低。老生代又分为老生代指针区和老生代数据区，前者包含大多数可能存在指向其他对象的指针的对象，后者只保存原始数据对象，这些对象没有指向其他对象的指针。</li>
<li>**大对象区(large_object_space)**：存放体积超越其他区域大小的对象，每个对象都会有自己的内存，垃圾回收不会移动大对象区。</li>
<li>**代码区(code_space)**：代码对象，会被分配在这里，唯一拥有执行权限的内存区域。</li>
<li>**map 区(map_space)**：存放 Cell 和 Map，每个区域都是存放相同大小的元素，结构简单。</li>
</ul>
<blockquote>
<p>垃圾回收的过程主要出现在新生代和老生代</p>
</blockquote>
<h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>在 V8 引擎的内存结构中，新生代主要用于存放存活时间较短的对象。新生代内存是由两个 semiSpace(半空间)构成的，在新生代的垃圾回收过程中主要采用了 <strong>Scavenge</strong> 算法。</p>
<p><strong>Scavenge</strong> 算法是一种典型的牺牲空间换取时间的算法，对于老生代内存来说，可能会存储大量对象，如果在老生代中使用这种算法，势必会造成内存资源的浪费，但是在新生代内存中，大部分对象的生命周期较短，在时间效率上表现可观，所以还是比较适合这种算法。</p>
<blockquote>
<p>在 Scavenge 算法的具体实现中，主要采用了 Cheney 算法，它将新生代内存一分为二，每一个部分的空间称为 semiSpace，其中处于激活状态的区域我们称为 From 空间，未激活(inactive new space)的区域我们称为 To 空间。这两个空间中，始终只有一个处于使用状态，另一个处于闲置状态。我们的程序中声明的对象首先会被分配到 From 空间，当进行垃圾回收时，如果 From 空间中尚有存活对象，则会被复制到 To 空间进行保存，非存活的对象会被自动回收。当复制完成后，From 空间和 To 空间完成一次角色互换，To 空间会变为新的 From 空间，原来的 From 空间则变为 To 空间。</p>
</blockquote>
<p>Scavenge 算法的垃圾回收过程主要就是将存活对象在 From 空间和 To 空间之间进行复制，同时完成两个空间之间的角色互换，因此该算法的缺点也比较明显，浪费了一半的内存用于复制。</p>
<h3 id="对象晋升"><a href="#对象晋升" class="headerlink" title="对象晋升"></a>对象晋升</h3><p>当一个对象在经过多次复制之后依旧存活，那么它会被认为是一个生命周期较长的对象，在下一次进行垃圾回收时，该对象会被直接转移到老生代中，这种对象从新生代转移到老生代的过程我们称之为<strong>晋升</strong>。<br>对象晋升的条件主要有以下两个：</p>
<ul>
<li>对象是否经历过一次 Scavenge 算法</li>
<li>To 空间的内存占比是否已经超过 25%</li>
</ul>
<p>默认情况下，我们创建的对象都会分配在 From 空间中，当进行垃圾回收时，在将对象从 From 空间复制到 To 空间之前，会先检查该对象的内存地址来判断是否已经经历过一次 Scavenge 算法，如果地址已经发生变动则会将该对象转移到老生代中，不会再被复制到 To 空间。</p>
<p>如果对象没有经历过 Scavenge 算法，会被复制到 To 空间，但是如果此时 To 空间的内存占比已经超过 25%，则该对象依旧会被转移到老生代。</p>
<p>之所以有 25%的内存限制是因为 To 空间在经历过一次 Scavenge 算法后会和 From 空间完成角色互换，会变为 From 空间，后续的内存分配都是在 From 空间中进行的，如果内存使用过高甚至溢出，则会影响后续对象的分配，因此超过这个限制之后对象会被直接转移到老生代来进行管理。</p>
<h3 id="老生代"><a href="#老生代" class="headerlink" title="老生代"></a>老生代</h3><p>在老生代中，因为管理着大量的存活对象，如果依旧使用 Scavenge 算法的话，很明显会浪费一半的内存，因此已经不再使用 Scavenge 算法，而是采用新的算法 Mark-Sweep(标记清除)和 Mark-Compact(标记整理)来进行管理。</p>
<p>在早前有一种算法叫做引用计数，该算法的原理比较简单，就是看对象是否还有其他引用指向它，如果没有指向该对象的引用，则该对象会被视为垃圾并被垃圾回收器回收，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 创建了两个对象obj1和obj2，其中obj2作为obj1的属性被obj1引用，因此不会被垃圾回收</span><br><span class="line">let obj1 = &#123;</span><br><span class="line">    obj2: &#123;</span><br><span class="line">        a: 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建obj3并将obj1赋值给obj3，让两个对象指向同一个内存地址</span><br><span class="line">let obj3 = obj1;</span><br><span class="line"></span><br><span class="line">// 将obj1重新赋值，此时原来obj1指向的对象现在只由obj3来表示</span><br><span class="line">obj1 = null;</span><br><span class="line"></span><br><span class="line">// 创建obj4并将obj3.obj2赋值给obj4</span><br><span class="line">// 此时obj2所指向的对象有两个引用：一个是作为obj3的属性，另一个是变量obj4</span><br><span class="line">let obj4 = obj3.obj2;</span><br><span class="line"></span><br><span class="line">// 将obj3重新赋值，此时本可以对obj3指向的对象进行回收，但是因为obj3.obj2被obj4所引用，因此依旧不能被回收</span><br><span class="line">obj3 = null;</span><br><span class="line"></span><br><span class="line">// 此时obj3.obj2已经没有指向它的引用，因此obj3指向的对象在此时可以被回收</span><br><span class="line">obj4 = null;</span><br></pre></td></tr></table></figure>

<p>上述例子在经过一系列操作后最终对象会被垃圾回收，但是一旦我们碰到<strong>循环引用</strong>的场景，就会出现问题，我们看下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    let a = &#123;&#125;;</span><br><span class="line">    let b = &#123;&#125;;</span><br><span class="line">    a.a1 = b;</span><br><span class="line">    b.b1 = a;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p>这个例子中我们将对象 a 的 a1 属性指向对象 b，将对象 b 的 b1 属性指向对象 a，形成两个对象相互引用，在 foo 函数执行完毕后，函数的作用域已经被销毁，作用域中包含的变量 a 和 b 本应该可以被回收，但是因为采用了<strong>引用计数</strong>的算法，两个变量均存在指向自身的引用，因此依旧无法被回收，<strong>导致内存泄漏</strong>。</p>
<p>因此为了避免循环引用导致的内存泄漏问题，截至 2012 年所有的现代浏览器均放弃了这种算法，转而采用新的<strong>Mark-Sweep(标记清除)</strong> 和 <strong>Mark-Compact(标记整理)</strong> 算法。在上面循环引用的例子中，因为变量 a 和变量 b 无法从 window 全局对象访问到，因此无法对其进行标记，所以最终会被回收。</p>
<p><strong>Mark-Sweep(标记清除)</strong> 分为 <strong>标记</strong> 和 <strong>清除</strong> 两个阶段，在标记阶段会遍历堆中的所有对象，然后标记活着的对象，在清除阶段中，会将死亡的对象进行清除。<strong>Mark-Sweep</strong> 算法主要是通过判断某个对象是否可以被访问到，从而知道该对象是否应该被回收，具体步骤如下：</p>
<ul>
<li>垃圾回收器会在内部构建一个根列表，用于从根节点出发去寻找那些可以被访问到的变量。比如在 JavaScript 中，window 全局对象可以看成一个根节点。</li>
<li>然后，垃圾回收器从所有根节点出发，遍历其可以访问到的子节点，并将其标记为活动的，根节点不能到达的地方即为非活动的，将会被视为垃圾。</li>
<li>最后，垃圾回收器将会释放所有非活动的内存块，并将其归还给操作系统。</li>
</ul>
<blockquote>
<p>以下几种情况都可以作为根节点：</p>
<ul>
<li>全局对象</li>
<li>本地函数的局部变量和参数</li>
<li>当前嵌套调用链上的其他函数的变量和参数</li>
</ul>
</blockquote>
<p>但是 <strong>Mark-Sweep</strong> 算法存在一个问题，就是在经历过一次标记清除后，内存空间可能会出现不连续的状态，因为我们所清理的对象的内存地址可能不是连续的，所以就会出现内存碎片的问题，导致后面如果需要分配一个大对象而空闲内存不足以分配，就会提前触发垃圾回收，而这次垃圾回收其实是没必要的，因为我们确实有很多空闲内存，只不过是不连续的。</p>
<p>为了解决这种内存碎片的问题，**Mark-Compact(标记整理)**算法被提了出来，该算法主要就是用来解决内存的碎片化问题的，回收过程中将死亡对象清除后，在整理的过程中，会将活动的对象往堆内存的一端进行移动，移动完成后再清理掉边界外的全部内存，</p>
<p>由于 JS 的单线程机制，垃圾回收的过程会阻碍主线程同步任务的执行，待执行完垃圾回收后才会再次恢复执行主任务的逻辑，这种行为被称为**全停顿(stop-the-world)**。在标记阶段同样会阻碍主线程的执行，一般来说，老生代会保存大量存活的对象，如果在标记阶段将整个堆内存遍历一遍，那么势必会造成严重的卡顿。</p>
<p>因此，为了减少垃圾回收带来的停顿时间，V8 引擎又引入了 <strong>Incremental Marking(增量标记)</strong> 的概念，即将原本需要一次性遍历堆内存的操作改为增量标记的方式，先标记堆内存中的一部分对象，然后暂停，将执行权重新交给 JS 主线程，待主线程任务执行完毕后再从原来暂停标记的地方继续标记，直到标记完整个堆内存。这个理念其实有点像 React 框架中的 Fiber 架构，只有在浏览器的空闲时间才会去遍历 Fiber Tree 执行对应的任务，否则延迟执行，尽可能少地影响主线程的任务，避免应用卡顿，提升应用性能。</p>
<p>得益于增量标记的好处，V8 引擎后续继续引入了<strong>延迟清理(lazy sweeping)</strong> 和 <strong>增量式整理(incremental compaction)<strong>，让清理和整理的过程也变成增量式的。同时为了充分利用多核 CPU 的性能，也将引入</strong>并行标记</strong>和<strong>并行清理</strong>，进一步地减少垃圾回收对主线程的影响，为应用提升更多的性能。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tongxinyou.github.io/2022/11/06/%E7%BD%91%E7%BB%9C-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/tongju.github.io/images/avatar.gif">
      <meta itemprop="name" content="墨白">
      <meta itemprop="description" content="个人技术成长之路">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="墨白的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/tongju.github.io/2022/11/06/%E7%BD%91%E7%BB%9C-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E6%96%B9%E5%BC%8F/" class="post-title-link" itemprop="url">浏览器解析网站原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tongju.github.io/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1、解析-URl"><a href="#1、解析-URl" class="headerlink" title="1、解析 URl"></a>1、解析 URl</h2><p>浏览器首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。</p>
<h2 id="2、缓存判断"><a href="#2、缓存判断" class="headerlink" title="2、缓存判断"></a>2、缓存判断</h2><p>在浏览器加载资源的时候，首先会根据请求头的 <strong>expires</strong> 和 <strong>cache-control</strong> 判断是否命中强缓存策略，判断是否向远程服务器请求资源还是去本地获取缓存资源。</p>
<h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>在浏览器中，强缓存分为 Expires（http1.0 规范）、cache-control（http1.1 规范）两种。</p>
<h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p>Expires 是 http1.0 的规范，用于表示资源的过期时间的请求头字段，值是一个绝对时间，是由服务器端返回的。</p>
<p>在浏览器第一个请求资源时，服务器端的响应头会附上 Expires 这个响应字段，当浏览器在下一次请求这个资源时会根据上次的 expires 字段是否使用缓存资源（当请求时间小于服务端返回的到期时间，直接使用缓存数据）</p>
<blockquote>
<p>expires 是根据本地时间来判断的，假设客户端和服务器时间不同，会导致缓存命中误差</p>
</blockquote>
<h4 id="Cache-control"><a href="#Cache-control" class="headerlink" title="Cache-control"></a>Cache-control</h4><p>上面我们提到了 Expires 有个缺点，当客户端本地时间和服务器时间不一致时会产生误差，浏览器会直接向服务器请求新的资源，为了解决这个问题，在 http1.1 规范中，提出了 cache-control 字段，且这个字段优先级高于上面提到的 Expires，值是相对时间。</p>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>上面提到的强缓存都是由本地浏览器在确定是否使用缓存，当浏览器没有命中强缓存时就会向浏览器发送请求，验证协商缓存是否命中，如果缓存命中则返回 304 状态码，否则返回新的资源数据。</p>
<p>协商缓存（也叫对比缓存）是由服务器来确定资源是否可用，这将涉及到两组字段成对出现的，在浏览器第一次发出请求时会带上字段（<strong>Last-Modified</strong> 或者 <strong>ETag</strong>），则后续请求则会带上对于的请求字段（<strong>if-modified-since</strong> 或者 <strong>if-none-Match</strong>），若响应头没有 <strong>Last-Modified</strong> 或者 <strong>ETag</strong>，则请求头也不会有对应的字段</p>
<ul>
<li><strong>Last-modified</strong> 表示本地文件最后修改时间，由服务器返回</li>
<li><strong>if-modified-since</strong> 是浏览器在请求数据时返回的，值是上次浏览器返回的 Last-modified</li>
<li><strong>ETag</strong> 是一个文件的唯一标识符，当资源发生变化时这个 ETag 就会发生变化。弥补了上面 last-modified 可能出现文件内容没有变化但是 last-modified 发生了变化出现重新向服务器请求资源情况。这个值也是又服务器返回的</li>
<li><strong>if-none-match</strong> 是浏览器请求数据时带上的字段，值是上次服务器返回的 ETag</li>
</ul>
<h2 id="3、DNS-解析"><a href="#3、DNS-解析" class="headerlink" title="3、DNS 解析"></a>3、DNS 解析</h2><p>首先需要获取的是输入的 URL 中的域名的 IP 地址(域名其实就是 ip 地址的别名),DNS 解析其实就是把域名解析成 ip 地址。</p>
<p>首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。</p>
<p>本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。</p>
<p><font color="red">用户向本地 DNS 服务器发起请求属于<strong>递归请求</strong>，本地 DNS 服务器向各级域名服务器发起请求属于<strong>迭代请求</strong>。</font></p>
<h2 id="4、建立-TCP-连接"><a href="#4、建立-TCP-连接" class="headerlink" title="4、建立 TCP 连接"></a>4、建立 TCP 连接</h2><blockquote>
<ol>
<li>首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号。</li>
<li>服务端接收到请求后向客户端发送一个 SYN ACK 报文段，确认连接请求，并且也向客户端发送一个随机序号。</li>
<li>客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个 ACK 确认报文段。</li>
<li>服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。</li>
</ol>
</blockquote>
<h2 id="5、发送-HTTP-请求"><a href="#5、发送-HTTP-请求" class="headerlink" title="5、发送 HTTP 请求"></a>5、发送 HTTP 请求</h2><blockquote>
<ul>
<li>TCP 是底层通讯协议，定义的是数据传输和连接方式的规范；</li>
<li>HTTP 是应用层协议，定义的是传输数据的内容的规范；</li>
<li>HTTP 协议中的数据是利用 TCP 协议传输的，所以支持 HTTP 也就一定支持 TCP。</li>
</ul>
</blockquote>
<p>如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程:</p>
<ol>
<li>首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。</li>
<li>服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。</li>
<li>客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。</li>
<li>服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。</li>
<li>这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。</li>
</ol>
<p>TLS 握手的关键在于利用通信双发生成的随机字符串和服务端的证书公钥生成一个双方经过协商后的对称密钥，这样通信双方就可以使用这个对称密钥在后续的数据传输中加密消息数据，防止中间人的监听和攻击，保证通讯安全。</p>
<blockquote>
<p>HTTPS 连接 需要 7 次握手，3 次 TCP + 4 次 TLS。</p>
</blockquote>
<h2 id="6、-服务器处理请求"><a href="#6、-服务器处理请求" class="headerlink" title="6、 服务器处理请求"></a>6、 服务器处理请求</h2><p>HTTP 请求一般可以分为两类，<strong>静态资源</strong> 和 <strong>动态资源</strong>。</p>
<p>请求访问静态资源，这个就直接根据 url 地址去服务器里找就好了。</p>
<p>请求动态资源的话，就需要 web server 把不同请求，委托给服务器上处理相应请求的程序进行处理（例如 CGI 脚本，JSP 脚本，servlets，ASP 脚本，服务器端 JavaScript，或者一些其它的服务器端技术等），然后返回后台程序处理产生的结果作为响应，发送到客户端。</p>
<h2 id="7、渲染页面"><a href="#7、渲染页面" class="headerlink" title="7、渲染页面"></a>7、渲染页面</h2><ol>
<li>浏览器首先会根据 html 文件构建 DOM 树，</li>
<li>根据解析到的 css 文件构建 CSSOM 树，</li>
<li>如果遇到 script 标签，则判断是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。</li>
<li>当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。</li>
<li>渲染树构建好后，会根据渲染树来进行布局。</li>
<li>布局完成后，最后使用浏览器的 UI 接口对页面进行绘制， 这个时候整个页面就显示出来了。</li>
</ol>
<h2 id="8、TCP-四次挥手"><a href="#8、TCP-四次挥手" class="headerlink" title="8、TCP 四次挥手"></a>8、TCP 四次挥手</h2><p>最后一步是 TCP 断开连接的四次挥手过程。</p>
<ol>
<li><p>若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。</p>
</li>
<li><p>服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。</p>
</li>
<li><p>但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。</p>
</li>
<li><p>客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。</p>
</li>
<li><p>当服务端收到确认应答后，也便进入 CLOSED 状态。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tongxinyou.github.io/2022/11/04/%E7%BD%91%E7%BB%9C-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/tongju.github.io/images/avatar.gif">
      <meta itemprop="name" content="墨白">
      <meta itemprop="description" content="个人技术成长之路">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="墨白的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/tongju.github.io/2022/11/04/%E7%BD%91%E7%BB%9C-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">跨域问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tongju.github.io/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="跨域的定义"><a href="#跨域的定义" class="headerlink" title="跨域的定义"></a>跨域的定义</h2><p>跨域问题指的是不同站点之间，使用 ajax 无法相互调用的问题。<strong>跨域问题本质是浏览器的一种保护机制，它的初衷是为了保证用户的安全，防止恶意网站窃取数据。</strong> 但这个保护机制也带来了新的问题，它的问题是给不同站点之间的正常调用，也带来的阻碍，所以<strong>在浏览器环境下，跨<font color="red">域</font>是指一个<font color="red">域</font>下的文档或脚本试图去请求另一个<font color="red">域</font>下的资源。</strong></p>
<blockquote>
<p><strong><font color="red">域</font></strong> :由协议+域名+端口组成</p>
</blockquote>
<p>正常情况下，如果我们通过 ajax 去请求另一个域下的资源时是不会成功的，浏览器默认会阻止这种行为，因为它违背了浏览器的<strong>同源策略</strong>。</p>
<h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><blockquote>
<p>同源策略（SOP: Same Origin Policy）是一种约定，由 Netscape 公司 1995 年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 XSS、CSFR 等攻击。</p>
</blockquote>
<p>简单来说就是指 <strong>协议 + 域名 + 端口</strong> 三者相同，如果违背了同源策略那么以下行为将得不到浏览器的支持：</p>
<p>1、获取 Cookie、LocalStorage 等<br>2、获取 DOM 和 Js 对象<br>3、发送 AJAX 请求</p>
<h2 id="跨域的三种情况"><a href="#跨域的三种情况" class="headerlink" title="跨域的三种情况"></a>跨域的三种情况</h2><p>在请求时，如果出现了以下情况中的任意一种，那么它就是跨域请求：</p>
<p>1、协议不同，如 http 和 https；<br>2、域名不同；<br>3、端口不同。</p>
<p>具体情况入下表：</p>
<table>
<thead>
<tr>
<th>当前的 URL</th>
<th>被请求的 URL</th>
<th>是否跨域</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="http://wwww.test.com/">http://wwww.test.com/</a></td>
<td><a target="_blank" rel="noopener" href="http://wwww.test.com/index.html">http://wwww.test.com/index.html</a></td>
<td>否</td>
<td>同源（协议、域名、端口号相同）</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://wwww.test.com/">http://wwww.test.com/</a></td>
<td><a target="_blank" rel="noopener" href="https://wwww.test.com/index.html">https://wwww.test.com/index.html</a></td>
<td>跨域</td>
<td>协议不同（http&#x2F;https）</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://wwww.test.com/">http://wwww.test.com/</a></td>
<td><a target="_blank" rel="noopener" href="http://wwww.baidu.com/">http://wwww.baidu.com/</a></td>
<td>跨域</td>
<td>主域名不同（test&#x2F;baidu）</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://wwww.test.com/">http://wwww.test.com/</a></td>
<td><a target="_blank" rel="noopener" href="http://blog.test.com/">http://blog.test.com/</a></td>
<td>跨域</td>
<td>子域名不同（www&#x2F;blog）</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://wwww.test.com:8080/">http://wwww.test.com:8080/</a></td>
<td><a target="_blank" rel="noopener" href="http://wwww.test.com:7001/">http://wwww.test.com:7001/</a></td>
<td>跨域</td>
<td>端口号不同（8080&#x2F;7001）</td>
</tr>
</tbody></table>
<h2 id="跨域解决方法"><a href="#跨域解决方法" class="headerlink" title="跨域解决方法"></a>跨域解决方法</h2><p>有多种方式解决跨域问题，常见的有：</p>
<ul>
<li>代理，（常用）</li>
<li>CORS，（常用））</li>
<li>JSONP</li>
</ul>
<p>无论使用哪一种方式，都是要让浏览器知道，我这次跨域请求的是自己人，就不要拦截了。</p>
<h3 id="1、代理"><a href="#1、代理" class="headerlink" title="1、代理"></a>1、代理</h3><p>对于前端开发而言，大部分的跨域问题，都是通过代理解决的</p>
<p><strong>代理适用的场景是：生产环境不发生跨域，但开发环境发生跨域</strong></p>
<p>因此，只需要在开发环境使用代理解决跨域即可，这种代理又称之为开发代理</p>
<p><img src="/tongju.github.io/2022/11/04/%E7%BD%91%E7%BB%9C-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/daili.jpg" alt="代理"></p>
<p>在实际开发中，只需要对开发服务器稍加配置即可完成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// vue 的开发服务器代理配置</span><br><span class="line">// vue.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  devServer: &#123; // 配置开发服务器</span><br><span class="line">    proxy: &#123; // 配置代理</span><br><span class="line">      &quot;/api&quot;: &#123; // 若请求路径以 /api 开头</span><br><span class="line">        target: &quot;http://dev.taobao.com&quot;, // 将其转发到 http://dev.taobao.com</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2、-JSONP"><a href="#2、-JSONP" class="headerlink" title="2、 JSONP"></a>2、 JSONP</h3><p>在 CORS 出现之前，人们想了一种奇妙的办法来实现跨域，这就是 JSONP。<br>要实现 JSONP，需要浏览器和服务器来一个天衣无缝的绝妙配合。<br>JSONP 的做法是：<strong>当需要跨域请求时，不使用 AJAX，转而生成一个 script 元素去请求服务器，由于浏览器并不阻止 script 元素的请求，这样请求可以到达服务器。服务器拿到请求后，响应一段 JS 代码，这段代码实际上是一个函数调用，调用的是客户端预先生成好的函数，并把浏览器需要的数据作为参数传递到函数中，从而间接的把数据传递给客户端。</strong></p>
<p><img src="/tongju.github.io/2022/11/04/%E7%BD%91%E7%BB%9C-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/jsonp.jpg" alt="JSONP"></p>
<p>但 JSONP 有着明显的缺点，即其只能支持 GET 请求。</p>
<h3 id="3、COPRS"><a href="#3、COPRS" class="headerlink" title="3、COPRS"></a>3、COPRS</h3><p>CORS 是基于 http1.1 的一种跨域解决方案，它的全称是 Cross-Origin Resource Sharing，跨域资源共享。</p>
<p>它的总体思路是：如果浏览器要跨域访问服务器的资源，需要获得服务器的允许</p>
<p>而要知道，一个请求可以附带很多信息，从而会对服务器造成不同程度的影响<br>比如有的请求只是获取一些新闻，有的请求会改动服务器的数据<br>针对不同的请求，CORS 规定了三种不同的交互模式，分别是：</p>
<p>简单请求<br>需要预检的请求<br>附带身份凭证的请求</p>
<p>这三种模式从上到下层层递进，请求可以做的事越来越多，要求也越来越严格。<br>下面分别说明三种请求模式的具体规范。</p>
<h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>当浏览器端运行了一段 ajax 代码（无论是使用 XMLHttpRequest 还是 fetch api），浏览器会首先判断它属于哪一种请求模式</p>
<h5 id="简单请求的判定"><a href="#简单请求的判定" class="headerlink" title="简单请求的判定"></a>简单请求的判定</h5><p>当请求同时满足以下条件时，浏览器会认为它是一个简单请求：</p>
<p>1、请求方法属于下面的一种：</p>
<ul>
<li>get</li>
<li>post</li>
<li>head</li>
</ul>
<p>2、请求头仅包含安全的字段，常见的安全字段如下：</p>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Content-Type</li>
<li>DPR</li>
<li>Downlink</li>
<li>Save-Data</li>
<li>Viewport-Width</li>
<li>Width</li>
</ul>
<p>3、请求头如果包含 <strong>Content-Type</strong>，仅限下面的值之一：</p>
<ul>
<li>text&#x2F;plain</li>
<li>multipart&#x2F;form-data</li>
<li>application&#x2F;x-www-form-urlencoded</li>
</ul>
<p>如果以上三个条件同时满足，浏览器判定为简单请求。</p>
<p>下面是一些例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 简单请求</span><br><span class="line">fetch(&#x27;http://crossdomain.com/api/news&#x27;);</span><br><span class="line"></span><br><span class="line">// 请求方法不满足要求，不是简单请求</span><br><span class="line">fetch(&#x27;http://crossdomain.com/api/news&#x27;, &#123;</span><br><span class="line">  method: &#x27;PUT&#x27;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 加入了额外的请求头，不是简单请求</span><br><span class="line">fetch(&#x27;http://crossdomain.com/api/news&#x27;, &#123;</span><br><span class="line">  headers: &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 简单请求</span><br><span class="line">fetch(&#x27;http://crossdomain.com/api/news&#x27;, &#123;</span><br><span class="line">  method: &#x27;post&#x27;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// content-type不满足要求，不是简单请求</span><br><span class="line">fetch(&#x27;http://crossdomain.com/api/news&#x27;, &#123;</span><br><span class="line">  method: &#x27;post&#x27;,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    &#x27;content-type&#x27;: &#x27;application/json&#x27;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="简单请求的交互规范"><a href="#简单请求的交互规范" class="headerlink" title="简单请求的交互规范"></a>简单请求的交互规范</h5><p>当浏览器判定某个 ajax 跨域请求是简单请求时，会发生以下的事情</p>
<p>1.请求头中会自动添加 Origin 字段</p>
<p>比如，在页面<strong><a target="_blank" rel="noopener" href="http://my.com/index.html">http://my.com/index.html</a></strong>中有以下代码造成了跨域</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 简单请求</span><br><span class="line">fetch(&#x27;http://crossdomain.com/api/news&#x27;);</span><br></pre></td></tr></table></figure>

<p>请求发出后，请求头会是下面的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /api/news/ HTTP/1.1</span><br><span class="line">Host: crossdomain.com</span><br><span class="line">Connection: keep-alive</span><br><span class="line">...</span><br><span class="line">Referer: http://my.com/index.html</span><br><span class="line">Origin: http://my.com</span><br></pre></td></tr></table></figure>

<p>最后一行 Origin 字段会告诉服务器，是哪个源地址在跨域请求</p>
<p>2.服务器响应头中应包含 <strong>Access-Control-Allow-Origin</strong></p>
<p>当服务器收到请求后，如果允许该请求跨域访问，需要在响应头中添加 Access-Control-Allow-Origin 字段</p>
<p>该字段的值可以是：</p>
<ul>
<li>*：表示我很开放，什么人我都允许访问</li>
<li>具体的源：比如<a target="_blank" rel="noopener" href="http://my.com,表示我就允许你访问/">http://my.com，表示我就允许你访问</a></li>
</ul>
<blockquote>
<p>实际上，这两个值对于客户端<a target="_blank" rel="noopener" href="http://my.com而言,都一样,因为客户端才不会管其他源服务器允不允许,就关心自己是否被允许/">http://my.com而言，都一样，因为客户端才不会管其他源服务器允不允许，就关心自己是否被允许</a><br>当然，服务器也可以维护一个可被允许的源列表，如果请求的 Origin 命中该列表，才响应*或具体的源<br><strong>为了避免后续的麻烦，强烈推荐响应具体的源</strong></p>
</blockquote>
<p>假设服务器做出了以下的响应：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Tue, 21 Apr 2020 08:03:35 GMT</span><br><span class="line">...</span><br><span class="line">Access-Control-Allow-Origin: http://my.com</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">消息体中的数据</span><br></pre></td></tr></table></figure>

<p>当浏览器看到服务器允许自己访问后，它就把响应顺利的交给 js，以完成后续的操作</p>
<h4 id="需要预检的请求"><a href="#需要预检的请求" class="headerlink" title="需要预检的请求"></a>需要预检的请求</h4><p>简单的请求对服务器的威胁不大，所以允许使用上述的简单交互即可完成。<br>但是，如果浏览器不认为这是一种简单请求，就会按照下面的流程进行：</p>
<p>1、<strong>浏览器发送预检请求，询问服务器是否允许</strong><br>2、<strong>服务器允许</strong><br>3、<strong>浏览器发送真实请求</strong><br>4、<strong>服务器完成真实的响应</strong></p>
<p>比如，在页面<a target="_blank" rel="noopener" href="http://my.com/index.html%E4%B8%AD%E6%9C%89%E4%BB%A5%E4%B8%8B%E4%BB%A3%E7%A0%81%E9%80%A0%E6%88%90%E4%BA%86%E8%B7%A8%E5%9F%9F">http://my.com/index.html中有以下代码造成了跨域</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 需要预检的请求</span><br><span class="line">fetch(&#x27;http://crossdomain.com/api/user&#x27;, &#123;</span><br><span class="line">  method: &#x27;POST&#x27;, // post 请求</span><br><span class="line">  headers: &#123;</span><br><span class="line">    // 设置请求头</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 2,</span><br><span class="line">    &#x27;content-type&#x27;: &#x27;application/json&#x27;,</span><br><span class="line">  &#125;,</span><br><span class="line">  body: JSON.stringify(&#123; name: &#x27;袁小进&#x27;, age: 18 &#125;), // 设置请求体</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>浏览器发现它不是一个简单请求，则会按照下面的流程与服务器交互</p>
<h5 id="1-浏览器发送预检请求，询问服务器是否允许"><a href="#1-浏览器发送预检请求，询问服务器是否允许" class="headerlink" title="1.浏览器发送预检请求，询问服务器是否允许"></a>1.浏览器发送预检请求，询问服务器是否允许</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS /api/user HTTP/1.1</span><br><span class="line">Host: crossdomain.com</span><br><span class="line">...</span><br><span class="line">Origin: http://my.com</span><br><span class="line">Access-Control-Request-Method: POST</span><br><span class="line">Access-Control-Request-Headers: a, b, content-type</span><br></pre></td></tr></table></figure>

<p>可以看出，这并非我们想要发出的真实请求，请求中不包含我们的请求头，也没有消息体。</p>
<p>这是一个预检请求，它的目的是询问服务器，是否允许后续的真实请求。</p>
<p>预检请求没有请求体，它包含了后续真实请求要做的事情</p>
<p>预检请求有以下特征：</p>
<ul>
<li>请求方法为 OPTIONS</li>
<li>没有请求体</li>
<li>请求头中包含<ul>
<li>Origin：请求的源，和简单请求的含义一致</li>
<li>Access-Control-Request-Method：后续的真实请求将使用的请求方法</li>
<li>Access-Control-Request-Headers：后续的真实请求会改动的请求头</li>
</ul>
</li>
</ul>
<h5 id="2-服务器允许"><a href="#2-服务器允许" class="headerlink" title="2. 服务器允许"></a>2. 服务器允许</h5><p>服务器收到预检请求后，可以检查预检请求中包含的信息，如果允许这样的请求，需要响应下面的消息格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Tue, 21 Apr 2020 08:03:35 GMT</span><br><span class="line">...</span><br><span class="line">Access-Control-Allow-Origin: http://my.com</span><br><span class="line">Access-Control-Allow-Methods: POST</span><br><span class="line">Access-Control-Allow-Headers: a, b, content-type</span><br><span class="line">Access-Control-Max-Age: 86400</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>对于预检请求，不需要响应任何的消息体，只需要在响应头中添加：</p>
<ul>
<li>Access-Control-Allow-Origin：和简单请求一样，表示允许的源</li>
<li>Access-Control-Allow-Methods：表示允许的后续真实的请求方法</li>
<li>Access-Control-Allow-Headers：表示允许改动的请求头</li>
<li>Access-Control-Max-Age：告诉浏览器，多少秒内，对于同样的请求源、方法、头，都不需要再发送预检请求了</li>
</ul>
<h5 id="3-浏览器发送真实请求"><a href="#3-浏览器发送真实请求" class="headerlink" title="3. 浏览器发送真实请求"></a>3. 浏览器发送真实请求</h5><p>预检被服务器允许后，浏览器就会发送真实请求了，上面的代码会发生下面的请求数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /api/user HTTP/1.1</span><br><span class="line">Host: crossdomain.com</span><br><span class="line">Connection: keep-alive</span><br><span class="line">...</span><br><span class="line">Referer: http://my.com/index.html</span><br><span class="line">Origin: http://my.com</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;: &quot;xiaoming&quot;, &quot;age&quot;: 18 &#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-服务器响应真实请求"><a href="#4-服务器响应真实请求" class="headerlink" title="4. 服务器响应真实请求"></a>4. 服务器响应真实请求</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Tue, 21 Apr 2020 08:03:35 GMT</span><br><span class="line">...</span><br><span class="line">Access-Control-Allow-Origin: http://my.com</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">添加用户成功</span><br></pre></td></tr></table></figure>

<p>可以看出，当完成预检之后，后续的处理与简单请求相同<br>下图简述了整个交互过程</p>
<p><img src="/tongju.github.io/2022/11/04/%E7%BD%91%E7%BB%9C-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/yujianqingqiu.jpg" alt="预检的请求"></p>
<h4 id="附带身份凭证的请求"><a href="#附带身份凭证的请求" class="headerlink" title="附带身份凭证的请求"></a>附带身份凭证的请求</h4><p>默认情况下，ajax 的跨域请求并不会附带 cookie，这样一来，某些需要权限的操作就无法进行</p>
<p>不过可以通过简单的配置就可以实现附带 cookie</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// xhr</span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = true;</span><br><span class="line"></span><br><span class="line">// fetch api</span><br><span class="line">fetch(url, &#123;</span><br><span class="line">  credentials: &#x27;include&#x27;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这样一来，该跨域的 ajax 请求就是一个附带身份凭证的请求<br>当一个请求需要附带 cookie 时，无论它是简单请求，还是预检请求，都会在请求头中添加 cookie 字段<br>而服务器响应时，需要明确告知客户端：服务器允许这样的凭据<br>告知的方式也非常的简单，只需要在响应头中添加：Access-Control-Allow-Credentials: true 即可<br>对于一个附带身份凭证的请求，若服务器没有明确告知，浏览器仍然视为跨域被拒绝。<br>另外要特别注意的是：<strong>对于附带身份凭证的请求，服务器不得设置 Access-Control-Allow-Origin 的值为*。这就是为什么不推荐使用*的原因</strong>.</p>
<h3 id="最后补充"><a href="#最后补充" class="headerlink" title="最后补充"></a>最后补充</h3><p>在跨域访问时，JS 只能拿到一些最基本的响应头，如：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头。<br><strong>Access-Control-Expose-Headers</strong> 头让服务器把允许浏览器访问的头放入白名单，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Expose-Headers: authorization, a, b</span><br></pre></td></tr></table></figure>

<p>这样 JS 就能够访问指定的响应头了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tongxinyou.github.io/2022/11/03/js%E5%9F%BA%E7%A1%80-%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/tongju.github.io/images/avatar.gif">
      <meta itemprop="name" content="墨白">
      <meta itemprop="description" content="个人技术成长之路">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="墨白的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/tongju.github.io/2022/11/03/js%E5%9F%BA%E7%A1%80-%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">前端路由</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tongju.github.io/categories/js%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">js基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>对于前端路由来说， hash 和 history 都可以用于前后端分离项目，且两者有各自的特点和各自的使用场景，在使用过程中主要要了解当前项目所处的场景，以便于更好地判断使用哪一种路由模式更佳。</p>
<h2 id="前端路由原理"><a href="#前端路由原理" class="headerlink" title="前端路由原理"></a>前端路由原理</h2><h3 id="1、SPA"><a href="#1、SPA" class="headerlink" title="1、SPA"></a>1、SPA</h3><p><strong>SPA，即单页面应用(Single Page Application)。</strong> 所谓单页 Web 应用，就是只有一张 Web 页面的应用。单页应用程序 (SPA) 是加载单个 HTML 页面并在用户与应用程序交互时动态更新该页面的 Web 应用程序。浏览器一开始会加载必需的 HTML 、 CSS 和 JavaScript ，所有的操作都在这张页面上完成，都由 JavaScript 来控制。</p>
<p>现如今，为了配合单页面 Web 应用快速发展的节奏，各类前端组件化技术栈层出不穷。近几年来，通过不断的版本迭代， vue 和 react 两大技术栈脱颖而出，成为当下最受欢迎的两大技术栈。</p>
<h3 id="2、什么时候需要路由"><a href="#2、什么时候需要路由" class="headerlink" title="2、什么时候需要路由"></a>2、什么时候需要路由</h3><p>对于现代开发的项目来说，稍微复杂一点的 SPA ，都需要用到路由。而 vue-router 正是 vue 的路由标配，且 vue-router 有两种模式： hash 和 history 。</p>
<h2 id="Hash-模式"><a href="#Hash-模式" class="headerlink" title="Hash 模式"></a>Hash 模式</h2><h3 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h3><p>hash 模式是一种把前端路由的路径用井号 <strong>#</strong> 拼接在真实 <strong>url</strong> 后面的模式。当井号 # 后面的路径发生变化时，浏览器并不会重新发起请求，而是会<strong>触发 onhashchange 事件</strong>。</p>
<h3 id="2、网页-url-组成部分"><a href="#2、网页-url-组成部分" class="headerlink" title="2、网页 url 组成部分"></a>2、网页 url 组成部分</h3><ul>
<li>了解几个 url 的属性</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><div style="width: 150px">location.protocal</div></td>
<td><div style="width: 150px"> 协议 </div></td>
</tr>
<tr>
<td>location.hostname</td>
<td>主机名</td>
</tr>
<tr>
<td>location.host</td>
<td>主机</td>
</tr>
<tr>
<td>location.port</td>
<td>端口号</td>
</tr>
<tr>
<td>location.patchname</td>
<td>访问页面</td>
</tr>
<tr>
<td>location.search</td>
<td>搜索内容</td>
</tr>
<tr>
<td>location.hash</td>
<td>哈希值</td>
</tr>
</tbody></table>
<ul>
<li>演示</li>
</ul>
<p>下面用一个网址来演示以上属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//http://127.0.0.1:8001/01-hash.html?a=100&amp;b=20#/aaa/bbb</span><br><span class="line">location.protocal // &#x27;http:&#x27;</span><br><span class="line">localtion.hostname // &#x27;127.0.0.1&#x27;</span><br><span class="line">location.host // &#x27;127.0.0.1:8001&#x27;</span><br><span class="line">location.port //8001</span><br><span class="line">location.pathname //&#x27;01-hash.html&#x27;</span><br><span class="line">location.serach // &#x27;?a=100&amp;b=20&#x27;</span><br><span class="line">location.hash // &#x27;#/aaa/bbb&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="3、hash-的特点"><a href="#3、hash-的特点" class="headerlink" title="3、hash 的特点"></a>3、hash 的特点</h3><blockquote>
<ul>
<li>hash 变化会触发网页跳转，即浏览器的前进和后退。</li>
<li>hash 可以改变 url ，但是不会触发页面重新加载（hash 的改变是记录在 window.history 中），即不会刷新页面。也就是说，所有页面的跳转都是在客户端进行操作。因此，这并不算是一次 http 请求，所以这种模式不利于 SEO 优化。hash 只能修改 # 后面的部分，所以只能跳转到与当前 url 同文档的 url 。</li>
<li>hash 通过 window.onhashchange 的方式，来监听 hash 的改变，借此实现无刷新跳转的功能。</li>
<li>hash 永远不会提交到 server 端（可以理解为只在前端自生自灭）。</li>
</ul>
</blockquote>
<h2 id="History-模式"><a href="#History-模式" class="headerlink" title="History 模式"></a>History 模式</h2><h3 id="1、定义-1"><a href="#1、定义-1" class="headerlink" title="1、定义"></a>1、定义</h3><p>history API 是 H5 提供的新特性，允许开发者直接更改前端路由，即更新浏览器 URL 地址而不重新发起请求。</p>
<h3 id="2、与-hash-的区别"><a href="#2、与-hash-的区别" class="headerlink" title="2、与 hash 的区别"></a>2、与 hash 的区别</h3><p>用一个例子来演示， hash 与 history 在浏览器下刷新时的区别。具体如下：</p>
<p><strong>正常页面浏览</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/xxx 刷新页面</span><br><span class="line"></span><br><span class="line">https://github.com/xxx/yyy 刷新页面</span><br><span class="line"></span><br><span class="line">https://github.com/xxx/yyy/zzz 刷新页面</span><br></pre></td></tr></table></figure>

<p><strong>改造 H5 history 模式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/xxx 刷新页面</span><br><span class="line"></span><br><span class="line">https://github.com/xxx/yyy 前端跳转，不刷新页面</span><br><span class="line"></span><br><span class="line">https://github.com/xxx/yyy/zzz 前端跳转，不刷新页面</span><br></pre></td></tr></table></figure>

<h3 id="3、history-的-API"><a href="#3、history-的-API" class="headerlink" title="3、history 的 API"></a>3、history 的 API</h3><p>面阐述几种 HTML5 新增的 history API 。具体如下表：</p>
<table>
<thead>
<tr>
<th>API</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>history.pushState(data, title [, url])</td>
<td>pushState 主要用于往历史记录堆栈顶部添加一条记录。各参数解析如下：①data 会在 onpopstate 事件触发时作为参数传递过去；②title 为页面标题，当前所有浏览器都会忽略此参数；③url 为页面地址，可选，缺少时表示为当前页地址</td>
</tr>
<tr>
<td>history.replaceState(data, title [, url])</td>
<td>更改当前的历史记录，参数同上； 上面的 pushState 是添加，这个更改</td>
</tr>
<tr>
<td>history.state</td>
<td>用于存储以上方法的 data 数据，不同浏览器的读写权限不一样</td>
</tr>
<tr>
<td>window.onpopstate</td>
<td>响应 pushState 或者 replaceState 的调用</td>
</tr>
</tbody></table>
<h3 id="4、history-的特点"><a href="#4、history-的特点" class="headerlink" title="4、history 的特点"></a>4、history 的特点</h3><p>对于 history 来说，主要有以下特点：</p>
<ul>
<li>新的 url 可以是与当前 url 同源的任意 url ，也可以是与当前 url 一样的地址，但是这样会导致的一个问题是，会把重复的这一次操作记录到栈当中。</li>
<li>通过 history.state ，添加任意类型的数据到记录中。</li>
<li>可以额外设置 title 属性，以便后续使用。</li>
<li>通过 pushState 、 replaceState 来实现无刷新跳转的功能。</li>
</ul>
<h3 id="5、存在问题"><a href="#5、存在问题" class="headerlink" title="5、存在问题"></a>5、存在问题</h3><p>对于 history 来说，确实解决了不少 hash 存在的问题，但是也带来了新的问题。具体如下：</p>
<ul>
<li>使用 history 模式时，在对当前的页面进行刷新时，此时浏览器会重新发起请求。如果 nginx 没有匹配得到当前的 url ，就会出现 404 的页面。</li>
<li>而对于 hash 模式来说， 它虽然看着是改变了 url ，但不会被包括在 http 请求中。所以，它算是被用来指导浏览器的动作，并不影响服务器端。因此，改变 hash 并没有真正地改变 url ，所以页面路径还是之前的路径， nginx 也就不会拦截。</li>
<li>因此，在使用 history 模式时，需要通过服务端来允许地址可访问，如果没有设置，就很容易导致出现 404 的局面。</li>
</ul>
<h3 id="6、两者选择"><a href="#6、两者选择" class="headerlink" title="6、两者选择"></a>6、两者选择</h3><p>在实际的项目中，如何对这两者进行选择。具体如下：</p>
<ul>
<li>to B 的系统推荐用 hash ，相对简单且容易使用，且因为 hash 对 url 规范不敏感；</li>
<li>to C 的系统，可以考虑选择 H5 history ，但是需要服务端支持；</li>
<li>能先用简单的，就别用复杂的，要考虑成本和收益。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tongxinyou.github.io/2022/11/02/js%E5%9F%BA%E7%A1%80-%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/tongju.github.io/images/avatar.gif">
      <meta itemprop="name" content="墨白">
      <meta itemprop="description" content="个人技术成长之路">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="墨白的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/tongju.github.io/2022/11/02/js%E5%9F%BA%E7%A1%80-%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">遍历数组方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tongju.github.io/categories/js%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">js基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p><strong>1.语法</strong></p>
<blockquote>
<p>arr.forEach(callback(currentValue [, index [, array]])[, thisArg])</p>
</blockquote>
<p><strong>2.作用</strong></p>
<blockquote>
<p><strong>对数组的每个元素执行一次给定的函数</strong></p>
</blockquote>
<p><strong>3.参数</strong></p>
<blockquote>
<p>callback<br>为数组中每个元素执行的函数，该函数接收一至三个参数：</p>
</blockquote>
<blockquote>
<p>currentValue<br>数组中正在处理的当前元素。</p>
</blockquote>
<blockquote>
<p>index  可选<br>数组中正在处理的当前元素的索引。</p>
</blockquote>
<blockquote>
<p>array  可选<br>forEach()  方法正在操作的数组。</p>
</blockquote>
<blockquote>
<p>thisArg  可选<br>当执行回调函数  callback  时，用作  this  的值。</p>
</blockquote>
<p><strong>4.返回值</strong></p>
<blockquote>
<p><strong>undefined</strong></p>
</blockquote>
<p><strong>5.注意事项</strong></p>
<ul>
<li>forEach() 遍历的范围在第一次调用 callback 前就会确定。调用 forEach 后添加到数组中的项不会被 callback 访问到</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const ary = [1,2,3,4,5];</span><br><span class="line">ary.forEach(item =&gt;&#123;</span><br><span class="line">    if(item === 1)&#123;</span><br><span class="line">        ary.push(6) // 遍历开始后数组新增的项不会被遍历</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(item);</span><br><span class="line">&#125;)</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br><span class="line">// 4</span><br><span class="line">// 5</span><br></pre></td></tr></table></figure>

<ul>
<li>如果已经存在的值被改变，则传递给 callback 的值是 forEach() 遍历到他们那一刻的值。已删除的项不会被遍历到</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const ary = [1,2,3,4,5];</span><br><span class="line">ary.forEach(item =&gt;&#123;</span><br><span class="line">    if(item === 1)&#123;</span><br><span class="line">        ary.pop()//在遍历到数组第一项时就把最后一项删除了，被删除的项不会被遍历</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(item);</span><br><span class="line">&#125;)</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br><span class="line">// 4</span><br></pre></td></tr></table></figure>

<ul>
<li>如果已访问的元素在迭代时被删除了（例如使用 shift()），之后的元素将被跳过</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const ary = [1,2,3,4,5];</span><br><span class="line">ary.forEach(item =&gt;&#123;</span><br><span class="line">    if(item === 3)&#123;</span><br><span class="line">        ary.shift();//遍历到第2项时，以访问的元素被删除，则下一项跳过遍历</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(item);</span><br><span class="line">&#125;)</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br><span class="line">// 5</span><br></pre></td></tr></table></figure>

<ul>
<li>forEach() 为每个数组元素执行一次 callback 函数；与 map() 或者 reduce() 不同的是，它总是返回 undefined 值，并且不可链式调用。因为此特性，forEach 一般用于链式调用的结尾。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let ary = [1, 2, 3, 4, 5]</span><br><span class="line">let result = ary.forEach(item =&gt; &#123;&#125;)</span><br><span class="line">console.log(result) // undefined</span><br></pre></td></tr></table></figure>

<ul>
<li>除了抛出异常以外，没有办法中止或跳出 forEach() 循环。下面是 for 与 forEach 的对比。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const ary = [1, 2, 3, 4, 5];</span><br><span class="line">for (let i = 0; i &lt; ary.length; i++) &#123;</span><br><span class="line">    if(ary[i] === 3)&#123;</span><br><span class="line">        console.log(&quot;找到了&quot;);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(ary[i]);</span><br><span class="line">&#125;</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 找到了</span><br><span class="line">ary.forEach(item =&gt; &#123;</span><br><span class="line">    if(item === 3)&#123;</span><br><span class="line">        console.log(&quot;找到了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(item);</span><br><span class="line">&#125;)</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 找到了</span><br><span class="line">// 3</span><br><span class="line">// 4</span><br><span class="line">// 5</span><br></pre></td></tr></table></figure>

<ul>
<li>forEach()虽然不能跳出整个循环，但是可以跳出当前循环，作用与循环中的 continue 类似</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const ary = [1, 2, 3, 4, 5];</span><br><span class="line">ary.forEach(item =&gt; &#123;</span><br><span class="line">    if (item === 3) &#123;</span><br><span class="line">        console.log(&quot;找到了&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(item);</span><br><span class="line">&#125;)</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 找到了</span><br><span class="line">// 4</span><br><span class="line">// 5</span><br></pre></td></tr></table></figure>

<ul>
<li>forEach()中不可以使用 break 或者 continue，否则会报错 8、forEach()不对未初始化的值进行任何操作</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const ary = [1, 2, , 4];</span><br><span class="line">ary.forEach(item =&gt; &#123;</span><br><span class="line">    console.log(element);</span><br><span class="line">&#125;);</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 4</span><br></pre></td></tr></table></figure>

<ul>
<li>使用抛出异常的方式终止 forEach()循环</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    let ary = [1, 2, 3, 4, 5];</span><br><span class="line">    ary.forEach(item =&gt; &#123;</span><br><span class="line">        if (item === 3) &#123;</span><br><span class="line">            throw new Error(&quot;EndIterative&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(item);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">    if (e.message != &quot;EndIterative&quot;) &#123;</span><br><span class="line">        throw e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br></pre></td></tr></table></figure>

<p><strong>6.应用</strong><br>数组扁平化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function flatten(arr) &#123;</span><br><span class="line">    const result = [];</span><br><span class="line">    arr.forEach((item) =&gt; &#123;</span><br><span class="line">        if (Array.isArray(item))</span><br><span class="line">            result.push(...flatten(item));</span><br><span class="line">        else</span><br><span class="line">            result.push(item);</span><br><span class="line">    &#125;)</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p><strong>1.语法</strong></p>
<blockquote>
<p>var newArray &#x3D; arr.filter(callback(element[, index[, array]])[, thisArg])</p>
</blockquote>
<p><strong>2.作用</strong></p>
<blockquote>
<p><strong>使用传入的函数测试所有元素，并返回所有通过测试的元素组成的新数组</strong></p>
</blockquote>
<p><strong>3.参数</strong></p>
<blockquote>
<p>callback<br>用来测试数组的每个元素的函数。返回  true  表示该元素通过测试，保留该元素， false  则不保留。它接受以下三个参数：</p>
</blockquote>
<blockquote>
<p>element<br>数组中当前正在处理的元素。</p>
</blockquote>
<blockquote>
<p>index 可选<br>正在处理的元素在数组中的索引。</p>
</blockquote>
<blockquote>
<p>array 可选<br>调用了  filter  的数组本身。</p>
</blockquote>
<blockquote>
<p>thisArg 可选<br>执行  callback  时，用于  this  的值。</p>
</blockquote>
<p><strong>4.返回值</strong></p>
<blockquote>
<p><strong>由通过测试的元素组成的新数组，如果没有元素通过测试，则返回空数组</strong></p>
</blockquote>
<p><strong>5.实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var ary1 = [1, 2, 3, 4, 5];</span><br><span class="line">var ary2 = ary1.filter(value =&gt; value &gt; 3);</span><br><span class="line">console.log(ary2); // [4,5]</span><br></pre></td></tr></table></figure>

<p><strong>6.应用</strong></p>
<ul>
<li>数组对象的键值搜索</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let users = [</span><br><span class="line">&#123; &#x27;user&#x27;: &#x27;九九&#x27;, &#x27;age&#x27;: 18 &#125;,</span><br><span class="line">&#123; &#x27;user&#x27;: &#x27;八八&#x27;, &#x27;age&#x27;: 19 &#125;,</span><br><span class="line">&#123; &#x27;user&#x27;: &#x27;七七&#x27;, &#x27;age&#x27;: 20 &#125;,</span><br><span class="line">]</span><br><span class="line">let filtered = users.filter(n =&gt; n.age===18)</span><br><span class="line">console.log(filtered)   // [&#123;&#x27;user&#x27;: &#x27;九九&#x27;&#125;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>数组去重</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let ary = [1,1,2,2,3,3,4,4,5,5]</span><br><span class="line">let result = ary.filter((item, index, arr) =&gt; arr.indexOf(item) === index)</span><br><span class="line">// indexOf只返回找到的第一个值的下标</span><br><span class="line">console.log(result); // [1,2,3,4,5]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>去除空字符串以及 null 和 undefined<br>思路：利用了空字符串和 null、undefined 转化为 boolean 的结果为 false</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let ary = [&#x27;A&#x27;, &#x27;&#x27;, &#x27;B&#x27;, null, undefined, &#x27;C&#x27;, &#x27;  &#x27;]</span><br><span class="line">let result = ary.filter((item, idx, arr) =&gt; item &amp;&amp; item.trim())</span><br><span class="line">console.log(result) //[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p><strong>1.语法</strong></p>
<blockquote>
<p>var new_array &#x3D; arr.map(function callback(currentValue[, index[, array]]) { &#x2F;&#x2F; Return element for new_array }[, thisArg])</p>
</blockquote>
<p><strong>2.作用</strong></p>
<blockquote>
<p><strong>创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值</strong></p>
</blockquote>
<p><strong>3.参数</strong></p>
<blockquote>
<p>callback<br>生成新数组元素的函数，使用三个参数：</p>
</blockquote>
<blockquote>
<p>currentValue<br>callback  数组中正在处理的当前元素。</p>
</blockquote>
<blockquote>
<p>index 可选<br>callback  数组中正在处理的当前元素的索引。</p>
</blockquote>
<blockquote>
<p>array 可选<br>map  方法调用的数组。</p>
</blockquote>
<blockquote>
<p>thisArg 可选<br>执行  callback  函数时值被用作 this。</p>
</blockquote>
<p><strong>4.返回值</strong></p>
<blockquote>
<p><strong>一个由原数组每个元素执行回调函数后的结果组成的新数组</strong></p>
</blockquote>
<p><strong>5.实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let numbers = [1, 4, 9];</span><br><span class="line">let result = numbers.map(Math.sqrt);</span><br><span class="line"></span><br><span class="line">let numbers = [1, 4, 9];</span><br><span class="line">let result = numbers.map(num =&gt; num * 2);</span><br><span class="line">console.log(result); // [2,8,18]</span><br></pre></td></tr></table></figure>

<h3 id="every"><a href="#every" class="headerlink" title="every"></a>every</h3><p><strong>1.语法</strong></p>
<blockquote>
<p>arr.every(callback[, thisArg])</p>
</blockquote>
<p><strong>2.作用</strong></p>
<blockquote>
<p><strong>测试一个数组内的所有元素是否都能通过某个指定函数的测试</strong></p>
</blockquote>
<p><strong>3.参数</strong></p>
<blockquote>
<p>callback<br>用来测试每个元素的函数，它可以接收三个参数：</p>
</blockquote>
<blockquote>
<p>element<br>用于测试的当前值。</p>
</blockquote>
<blockquote>
<p>index 可选<br>用于测试的当前值的索引。</p>
</blockquote>
<blockquote>
<p>array 可选<br>调用  every  的当前数组。</p>
</blockquote>
<blockquote>
<p>thisArg<br>执行  callback  时使用的  this  值。</p>
</blockquote>
<p><strong>4.返回值</strong></p>
<blockquote>
<p><strong>布尔值</strong></p>
</blockquote>
<p><strong>5.实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr1 = [12, 5, 8, 130, 44];</span><br><span class="line">let arr2 = [12, 54, 18, 130, 44];</span><br><span class="line">arr1.every(x =&gt; x &gt;= 10); // false</span><br><span class="line">arr2.every(x =&gt; x &gt;= 10); // true</span><br></pre></td></tr></table></figure>

<h3 id="some"><a href="#some" class="headerlink" title="some"></a>some</h3><p><strong>1.语法</strong></p>
<blockquote>
<p>arr.some(callback(element[, index[, array]])[, thisArg])</p>
</blockquote>
<p><strong>2.作用</strong></p>
<blockquote>
<p><strong>测试数组中是不是至少有 1 个元素通过了被提供的函数测试</strong></p>
</blockquote>
<p><strong>3.参数</strong></p>
<blockquote>
<p>callback<br>用来测试每个元素的函数，接受三个参数：</p>
</blockquote>
<blockquote>
<p>element<br>数组中正在处理的元素。</p>
</blockquote>
<blockquote>
<p>index  可选<br>数组中正在处理的元素的索引值。</p>
</blockquote>
<blockquote>
<p>array 可选<br>some()被调用的数组。</p>
</blockquote>
<blockquote>
<p>thisArg 可选<br>执行  callback  时使用的  this  值。</p>
</blockquote>
<p><strong>4.返回值</strong></p>
<blockquote>
<p><strong>布尔值</strong></p>
</blockquote>
<p><strong>5.实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr1 = [1,2,3,4,5];</span><br><span class="line">let arr2 = [1,2,3,4,5,12];</span><br><span class="line">arr1.some(x =&gt; x &gt; 10); // false</span><br><span class="line">arr2.some(x =&gt; x &gt; 10); // true</span><br></pre></td></tr></table></figure>

<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p><strong>1.语法</strong></p>
<blockquote>
<p>arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])</p>
</blockquote>
<p><strong>2.作用</strong></p>
<blockquote>
<p><strong>对数组中的每个元素执行一个 reducer 函数，并将其结果汇总为单个返回值</strong></p>
</blockquote>
<p><strong>3.参数</strong></p>
<blockquote>
<p>callback<br>执行数组中每个值  (如果没有提供  initialValue 则第一个值除外)的函数，包含四个参数：</p>
</blockquote>
<blockquote>
<p>accumulator<br>累计器累计回调的返回值; 它是上一次调用回调时返回的累积值，或 initialValue。</p>
</blockquote>
<blockquote>
<p>currentValue<br>数组中正在处理的元素。</p>
</blockquote>
<blockquote>
<p>index  可选<br>数组中正在处理的当前元素的索引。 如果提供了 initialValue，则起始索引号为 0， 否则从索引 1 起始。</p>
</blockquote>
<blockquote>
<p>array 可选<br>调用 reduce()的数组</p>
</blockquote>
<blockquote>
<p>initialValue 可选<br>作为第一次调用  callback 函数时的第一个参数的值。 如果没有提供初始值，则将 使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。</p>
</blockquote>
<p><strong>4.返回值</strong></p>
<blockquote>
<p><strong>函数累计处理的结果</strong></p>
</blockquote>
<p><strong>5.实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 3, 4]</span><br><span class="line">let sum = arr.reduce((acc, cur) =&gt; &#123;</span><br><span class="line">    return acc + cur;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(sum); // 10</span><br></pre></td></tr></table></figure>

<h3 id="reduceRight"><a href="#reduceRight" class="headerlink" title="reduceRight"></a>reduceRight</h3><p><strong>1.语法</strong></p>
<blockquote>
<p>arr.reduceRight(callback(accumulator, currentValue[, index[, array]])[, initialValue])</p>
</blockquote>
<p><strong>2.作用</strong></p>
<blockquote>
<p><strong>接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值</strong></p>
</blockquote>
<p><strong>3.参数</strong></p>
<blockquote>
<p>callback<br>一个回调函数，用于操作数组中的每个元素，它可接受四个参数：</p>
</blockquote>
<blockquote>
<p>accumulator<br>累加器：上一次调用回调函数时，回调函数返回的值。首次调用回调函数时，如果  initialValue  存在，累 加器即为  initialValue，否则须为数组中的最后一个元素（详见下方  initialValue  处相关说明）。</p>
</blockquote>
<blockquote>
<p>currentValue<br>当前元素：当前被处理的元素。</p>
</blockquote>
<blockquote>
<p>index 可选<br>数组中当前被处理的元素的索引</p>
</blockquote>
<blockquote>
<p>array 可选<br>调用  reduceRight()  的数组。</p>
</blockquote>
<blockquote>
<p>initialValue 可选  <br>首次调用  callback  函数时，累加器  accumulator  的值。<br>如果未提供该初始值，则将使用数组中的最后一个元素，并跳过该元素。<br>如果不给出初始值，则需保证数组不为空。否则，在空数组上调用  reduce  或  reduceRight  且未提供初始值（例如  [].reduce( (acc, cur, idx, arr) &#x3D;&gt; {} ) ）的话，会导致类型错误  TypeError: reduce of empty array with no initial value。</p>
</blockquote>
<p><strong>4.返回值</strong></p>
<blockquote>
<p><strong>执行之后的值</strong></p>
</blockquote>
<h3 id="entires"><a href="#entires" class="headerlink" title="entires"></a>entires</h3><p><strong>1.语法</strong></p>
<blockquote>
<p>arr.entries()</p>
</blockquote>
<p><strong>2.作用</strong></p>
<blockquote>
<p><strong>返回一个新的 Array Iterator 对象，该对象包含数组中每个索引的键&#x2F;值对</strong></p>
</blockquote>
<p><strong>3.参数</strong></p>
<p>无</p>
<p><strong>4.返回值</strong></p>
<blockquote>
<p><strong>一个新的 Array 迭代器对象</strong></p>
</blockquote>
<p><strong>5.实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];</span><br><span class="line">let iterator = arr.entries();</span><br><span class="line">console.log(iterator.next().value); // [0, &quot;a&quot;]</span><br><span class="line">console.log(iterator.next().value); // [1, &quot;b&quot;]</span><br><span class="line">console.log(iterator.next().value); // [2, &quot;c&quot;]</span><br><span class="line">console.log(iterator.next().value); // undefined, 迭代器处于数组末尾时, 再迭代就会返回undefined</span><br></pre></td></tr></table></figure>

<p><strong>4.返回值</strong></p>
<blockquote>
<p><strong>执行之后的值</strong></p>
</blockquote>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p><strong>1.语法</strong></p>
<blockquote>
<p>arr.find(callback[, thisArg])</p>
</blockquote>
<p><strong>2.作用</strong></p>
<blockquote>
<p><strong>返回数组中满足提供的测试函数的第一个元素的值。都不满足则返回 undefined</strong></p>
</blockquote>
<p><strong>3.参数</strong></p>
<blockquote>
<p>callback<br>在数组每一项上执行的函数，接收 3 个参数：</p>
</blockquote>
<blockquote>
<p>element<br>当前遍历到的元素。</p>
</blockquote>
<blockquote>
<p>index 可选<br>当前遍历到的索引。</p>
</blockquote>
<blockquote>
<p>array 可选<br>数组本身。</p>
</blockquote>
<blockquote>
<p>thisArg 可选<br>执行回调时用作 this  的对象。</p>
</blockquote>
<p><strong>4.返回值</strong></p>
<blockquote>
<p><strong>数组中第一个满足所提供测试函数的元素的值，都不满足则返回 undefined</strong></p>
</blockquote>
<p><strong>5.实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 3, 5, 7, 8, 9, 10];</span><br><span class="line">let result = arr.find(value =&gt; &#123;</span><br><span class="line">    if (value % 2 == 0) &#123;</span><br><span class="line">        return value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(result); // 8</span><br></pre></td></tr></table></figure>

<h3 id="fineIndex"><a href="#fineIndex" class="headerlink" title="fineIndex"></a>fineIndex</h3><p><strong>1.语法</strong></p>
<blockquote>
<p>arr.findIndex(callback[, thisArg])</p>
</blockquote>
<p><strong>2.作用</strong></p>
<blockquote>
<p><strong>判断数组中是否有满足测试函数的项</strong></p>
</blockquote>
<p><strong>3.参数</strong></p>
<blockquote>
<p>callback<br>针对数组中的每个元素, 都会执行该回调函数, 执行时会自动传入下面三个参数:</p>
</blockquote>
<blockquote>
<p>element<br>当前元素。</p>
</blockquote>
<blockquote>
<p>index<br>当前元素的索引。</p>
</blockquote>
<blockquote>
<p>array<br>调用 findIndex 的数组。</p>
</blockquote>
<blockquote>
<p>thisArg<br>可选。执行 callback 时作为 this 对象的值。</p>
</blockquote>
<p><strong>4.返回值</strong></p>
<blockquote>
<p><strong>数组中通过提供测试函数的第一个元素的索引。若都未通过则返回-1</strong></p>
</blockquote>
<p><strong>5.实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 3, 5, 7, 8, 9, 10];</span><br><span class="line">let result = arr.findIndex(value =&gt; &#123;</span><br><span class="line">    if (value % 2 == 0) &#123;</span><br><span class="line">        return value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(result); // 4</span><br></pre></td></tr></table></figure>

<h3 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h3><p><strong>1.语法</strong></p>
<blockquote>
<p>arr.keys()</p>
</blockquote>
<p><strong>2.作用</strong></p>
<blockquote>
<p><strong>返回一个包含数组中每个索引键的 Array Iterator 对象</strong></p>
</blockquote>
<p><strong>3.参数</strong></p>
<p>无</p>
<p><strong>4.返回值</strong></p>
<blockquote>
<p><strong>一个新的 Array 迭代器对象</strong></p>
</blockquote>
<p><strong>5.实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr = [&quot;abc&quot;, &quot;xyz&quot;];</span><br><span class="line">let iterator = arr.keys();</span><br><span class="line">console.log(iterator.next()); // Object &#123;value: 0, done: false&#125;</span><br><span class="line">console.log(iterator.next()); // Object &#123;value: 1, done: false&#125;</span><br><span class="line">console.log(iterator.next()); // Object &#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure>

<h3 id="values"><a href="#values" class="headerlink" title="values"></a>values</h3><p><strong>1.语法</strong></p>
<blockquote>
<p>arr.values()</p>
</blockquote>
<p><strong>2.作用</strong></p>
<blockquote>
<p><strong>返回一个新的 Array Iterator 对象，该对象包含数组每个索引的值</strong></p>
</blockquote>
<p><strong>3.参数</strong></p>
<p>无</p>
<p><strong>4.返回值</strong></p>
<blockquote>
<p><strong>一个新的 Array 迭代器对象</strong></p>
</blockquote>
<p><strong>5.实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr = [&quot;abc&quot;, &quot;def&quot;];</span><br><span class="line">let iterator = arr.values();</span><br><span class="line">console.log(iterator.next().value); //abc</span><br><span class="line">console.log(iterator.next().value); //def</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tongxinyou.github.io/2022/11/01/js%E5%9F%BA%E7%A1%80-%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/tongju.github.io/images/avatar.gif">
      <meta itemprop="name" content="墨白">
      <meta itemprop="description" content="个人技术成长之路">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="墨白的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/tongju.github.io/2022/11/01/js%E5%9F%BA%E7%A1%80-%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">数组方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tongju.github.io/categories/js%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">js基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="ES6-新增构造方法"><a href="#ES6-新增构造方法" class="headerlink" title="ES6 新增构造方法"></a>ES6 新增构造方法</h2><h3 id="Array-form"><a href="#Array-form" class="headerlink" title="Array.form()"></a>Array.form()</h3><p><strong>1. 语法</strong></p>
<blockquote>
<p>Array.from(arrayLike[, mapFn[, thisArg]])</p>
</blockquote>
<p><strong>2. 作用</strong></p>
<p><strong>将类数组与可迭代对象转化为数组</strong></p>
<p><strong>3. 参数</strong></p>
<blockquote>
<p>arrayLike<br>想要转换成数组的伪数组对象或可迭代对象。<br>mapFn  可选<br>如果指定了该参数，新数组中的每个元素会执行该回调函数。<br>thisArg  可选<br>可选参数，执行回调函数  mapFn  时  this  对象。</p>
</blockquote>
<p><strong>4. 返回值</strong></p>
<p><strong>转化后的新数组</strong></p>
<p><strong>5.注意事项</strong></p>
<ul>
<li>该类数组对象必须具有 length 属性，用于指定数组的长度。如果没有 length 属性，那么 转换后的数组是一个空数组。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 没有length属性返回空数组</span><br><span class="line">let obj = &#123;</span><br><span class="line">    0:&#x27;a&#x27;,</span><br><span class="line">    1:&#x27;b&#x27;,</span><br><span class="line">    2:&#x27;c&#x27;</span><br><span class="line">&#125;</span><br><span class="line">Array.from(obj); // []</span><br></pre></td></tr></table></figure>

<ul>
<li>该类数组对象的属性名必须为数值型或字符串型的数字，且数字必须是以 0 开始</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// key不是数字或包含数字的字符串返回undefined</span><br><span class="line">let obj = &#123;</span><br><span class="line">    name:&#x27;九九欧&#x27;,</span><br><span class="line">    age:18,</span><br><span class="line">    length:2</span><br><span class="line">&#125;</span><br><span class="line">Array.from(obj); // [undefined, undefined]</span><br><span class="line"></span><br><span class="line">// key是数字但不是以0开始</span><br><span class="line">let obj = &#123;</span><br><span class="line">    2:&#x27;a&#x27;,</span><br><span class="line">    3:&#x27;b&#x27;,</span><br><span class="line">    4:&#x27;c&#x27;,</span><br><span class="line">    length:3</span><br><span class="line">&#125;</span><br><span class="line">Array.from(obj); // [undefined, undefined, &quot;a&quot;]</span><br><span class="line"></span><br><span class="line">// 满足所有条件</span><br><span class="line">let obj = &#123;</span><br><span class="line">    0:&#x27;a&#x27;,</span><br><span class="line">    1:&#x27;b&#x27;,</span><br><span class="line">    2:&#x27;c&#x27;,</span><br><span class="line">    length:3</span><br><span class="line">&#125;</span><br><span class="line">Array.from(obj); // [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br></pre></td></tr></table></figure>

<ul>
<li>Array.from()在转化对象时，要求过于苛刻，因此不适用于转化对象，它的应用场景主要是以下几个</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">从类数组对象(arguments)生成数组</span><br><span class="line">let fn = function()&#123;</span><br><span class="line">        console.log(Array.from(arguments));</span><br><span class="line">    &#125;</span><br><span class="line">    fn(1,2,3) // [1,2,3]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">从 String 生成数组</span><br><span class="line">    Array.from(&#x27;九九欧&#x27;); // [&quot;九&quot;,&quot;九&quot;,&quot;欧&quot;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">从Set生成数组</span><br><span class="line">    Array.from(new Set([&quot;九&quot;,&quot;九&quot;,&quot;欧&quot;,&quot;欧&quot;])); // [&quot;九&quot;,&quot;欧&quot;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">从Map生成数组</span><br><span class="line">    Array.from(new Map([[1, &#x27;a&#x27;], [2, &#x27;b&#x27;]])); // [[1, &#x27;a&#x27;], [2, &#x27;b&#x27;]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">生成一个从0开始到指定数字的定长连续数组</span><br><span class="line">    Array.from(&#123;length: 10&#125;, (v, i) =&gt; i); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h3><p><strong>1.语法</strong></p>
<blockquote>
<p>Array.of(element0[, element1[, …[, elementN]]])</p>
</blockquote>
<p><strong>2.作用</strong><br><strong>将参数依次转化为数组中的项</strong></p>
<p><strong>3.参数</strong><br><strong>任意个参数，将按顺序成为返回数组中的元素</strong></p>
<p><strong>4.返回值</strong><br><strong>转化后的新数组</strong></p>
<p><strong>5.Array.of()与 Array()的区别</strong><br>当传入多个参数时，两者之间没有区别</p>
<p>当传入一个参数且参数为数字时，区别如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Array.of(9);</span><br><span class="line">// [9]</span><br><span class="line">Array(9);</span><br><span class="line">// [empty × 9]</span><br></pre></td></tr></table></figure>

<h2 id="判断数组的方法"><a href="#判断数组的方法" class="headerlink" title="判断数组的方法"></a>判断数组的方法</h2><h3 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray()"></a>Array.isArray()</h3><p><strong>1.语法</strong></p>
<blockquote>
<p>Array.isArray(obj)</p>
</blockquote>
<p><strong>2.作用</strong><br><strong>判断传递的值是否是一个数组</strong></p>
<p><strong>3.参数</strong><br><strong>需要判断的值</strong></p>
<p><strong>4.返回值</strong></p>
<blockquote>
<p><strong>布尔值</strong></p>
</blockquote>
<p><strong>5.实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Array.isArray([])           // true</span><br><span class="line">Array.isArray(&#123;&#125;)           // false</span><br><span class="line">Array.isArray(&#x27;a&#x27;)          // false</span><br><span class="line">Array.isArray(1)            // false</span><br><span class="line">Array.isArray(null)         // false</span><br><span class="line">Array.isArray(undefined)    // false</span><br></pre></td></tr></table></figure>

<h2 id="改变自身值的方法"><a href="#改变自身值的方法" class="headerlink" title="改变自身值的方法"></a>改变自身值的方法</h2><h3 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h3><p><strong>1.语法</strong></p>
<blockquote>
<p>arr.pop()</p>
</blockquote>
<p><strong>2.作用</strong></p>
<blockquote>
<p><strong>删除数组中最后一个元素</strong></p>
</blockquote>
<p><strong>3.参数</strong><br>无</p>
<p><strong>4.返回值</strong></p>
<blockquote>
<p><strong>从数组中删除的元素（数组为空时，返回 undefined）</strong></p>
</blockquote>
<p><strong>5.实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let ary = [1,2,3,4];</span><br><span class="line">console.log(ary.pop()); // 4</span><br><span class="line">console.log(ary);       // [1,2,3]</span><br></pre></td></tr></table></figure>

<h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><p><strong>1.语法</strong></p>
<blockquote>
<p>arr.push(element1, …, elementN)</p>
</blockquote>
<p><strong>2.作用</strong></p>
<blockquote>
<p><strong>将一个或多个元素添加到数组的末尾</strong></p>
</blockquote>
<p><strong>3.参数</strong><br>被添加到数组末尾的元素</p>
<p><strong>4.返回值</strong></p>
<blockquote>
<p><strong>新数组的长度</strong></p>
</blockquote>
<p><strong>5.实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let ary = [1,2,3];</span><br><span class="line">ary.push(4);</span><br><span class="line">console.log(ary); // [1,2,3,4]</span><br></pre></td></tr></table></figure>

<p><strong>6.应用</strong></p>
<p>合并两个数组</p>
<p>思路：利用 apply 改变 this 的指向，以及 apply 传递参数时会将数组中的项以此传递</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let ary1 = [1,2,3];</span><br><span class="line">let ary2 = [4,5,6];</span><br><span class="line">let ary3 = Array.prototype.push.apply(ary1,ary2)</span><br><span class="line">console.log(ary1); // [1,2,3,4,5,6]</span><br><span class="line">console.log(ary3); // 6</span><br></pre></td></tr></table></figure>

<h3 id="shift"><a href="#shift" class="headerlink" title="shift"></a>shift</h3><p><strong>1.语法</strong></p>
<blockquote>
<p>arr.shift()</p>
</blockquote>
<p><strong>2.作用</strong></p>
<blockquote>
<p><strong>删除数组的第一个元素</strong></p>
</blockquote>
<p><strong>3.参数</strong><br>无</p>
<p><strong>4.返回值</strong></p>
<blockquote>
<p><strong>被删除的元素</strong></p>
</blockquote>
<p><strong>5.实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let ary = [1,2,3];</span><br><span class="line">let result = ary.shift();</span><br><span class="line">console.log(ary);     // [2,3]</span><br><span class="line">console.log(result);  // 1</span><br></pre></td></tr></table></figure>

<h3 id="unShift"><a href="#unShift" class="headerlink" title="unShift"></a>unShift</h3><p><strong>1.语法</strong></p>
<blockquote>
<p>arr.unShift(element1, …, elementN)</p>
</blockquote>
<p><strong>2.作用</strong></p>
<blockquote>
<p><strong>在数组的开头添加一个或多个元素</strong></p>
</blockquote>
<p><strong>3.参数</strong><br>要添加到数组开头的元素或多个元素</p>
<p><strong>4.返回值</strong></p>
<blockquote>
<p><strong>新数组的长度</strong></p>
</blockquote>
<p><strong>5.实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let ary = [4, 5, 6];</span><br><span class="line">let result = ary.unShift(1, 2, 3);</span><br><span class="line">console.log(ary);    // [1, 2, 3, 4, 5, 6]</span><br><span class="line">console.log(result); // 6</span><br></pre></td></tr></table></figure>

<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p><strong>1.语法</strong></p>
<blockquote>
<p>arr.sort([compareFunction])</p>
</blockquote>
<p><strong>2.作用</strong></p>
<blockquote>
<p><strong>数组的元素进行排序</strong></p>
</blockquote>
<p><strong>3.参数</strong></p>
<blockquote>
<p>compareFunction  可选<br>用来指定按某种顺序进行排列的函数。<br>如果省略，则元素按照转换为的字符串的各个字符的 Unicode 位点进行排序。<br>firstEl<br>第一个用于比较的元素。<br>secondEl<br>第二个用于比较的元素。</p>
</blockquote>
<p><strong>4.返回值</strong></p>
<blockquote>
<p><strong>排序后的数组</strong></p>
</blockquote>
<p><strong>5.实例</strong><br>若 compareFn(a, b) &lt; 0，那么 a 将排到 b 前面（数字升序）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let ary = [2,4,1,6,7,3,8,9,5];</span><br><span class="line">ary.sort(function(a,b)&#123;</span><br><span class="line">    return a-b;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(ary); // [1,2,3,4,5,6,7,8,9]</span><br></pre></td></tr></table></figure>

<p>若 compareFn(a, b) &gt; 0，那么 a , b 将调换位置（数字降序）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let ary = [2,4,1,6,7,3,8,9,5];</span><br><span class="line">ary.sort(function(a,b)&#123;</span><br><span class="line">    return b-a;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(ary); // [9,8,7,6,5,4,3,2,1]</span><br></pre></td></tr></table></figure>

<p>省略参数时，元素按照转换为的字符串的各个字符的 Unicode 位点进行排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let ary = [9,8,7,6,5,4,3,2,1,0]</span><br><span class="line">ary.sort();</span><br><span class="line">console.log(ary);  // [0,1,2,3,4,5,6,7,8,9]</span><br><span class="line"></span><br><span class="line">let ary = [&quot;e&quot;,&quot;d&quot;,&quot;c&quot;,&quot;b&quot;,&quot;a&quot;]</span><br><span class="line">ary.sort();</span><br><span class="line">console.log(ary); // [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]</span><br></pre></td></tr></table></figure>

<h3 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h3><p><strong>1.语法</strong></p>
<blockquote>
<p>array.splice(start[, deleteCount[, item1[, item2[, …]]]])</p>
</blockquote>
<p><strong>2.作用</strong></p>
<blockquote>
<p><strong>删除或替换现有元素、原地添加新的元素</strong></p>
</blockquote>
<p><strong>3.参数</strong></p>
<blockquote>
<p>start</p>
<ul>
<li>指定修改的开始位置（从 0 计数）。如果超出了数组的长度，则从数组末尾开始添加内容；</li>
<li>如果是负值，则表示从数组末位开始的第几位（从-1 计数，这意味着-n 是倒数第 n 个元素并且等价于 array.length-n）；</li>
<li>如果负数的绝对值大于数组的长度，则表示开始位置为第 0 位。</li>
</ul>
</blockquote>
<blockquote>
<p>deleteCount （可选）</p>
<ul>
<li>整数，表示要移除的数组元素的个数。</li>
<li>如果  deleteCount  大于  start  之后的元素的总数，则从  start  后面的元素都将被删除（含第  start  位）。</li>
<li>如果  deleteCount  被省略了，或者它的值大于等于 array.length - start</li>
<li>(也就是说如果它大于或者等于 start 之后的所有元素的数量)，那么 start 之后数组的所有元素都会被删除。</li>
<li>如果  deleteCount  是 0 或者负数，则不移除元素。这种情况下，至少应添加一个新元素。</li>
</ul>
</blockquote>
<blockquote>
<p>item1, item2, …（可选）</p>
<ul>
<li>要添加进数组的元素,从 start  位置开始。如果不指定，则  splice()  将只删除数组元素。</li>
</ul>
</blockquote>
<p><strong>4.返回值</strong></p>
<blockquote>
<p><strong>由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组。</strong></p>
</blockquote>
<p><strong>5.实例</strong></p>
<ul>
<li>删除某个元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let ary = [1,2,3,3,4,5,6]</span><br><span class="line">ary.splice(2,1);</span><br><span class="line">console.log(ary); // [1,2,3,4,5,6]</span><br></pre></td></tr></table></figure>

<ul>
<li>替换某个元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let ary = [1,2,3,3,5,6]</span><br><span class="line">ary.splice(3,1,4);</span><br><span class="line">console.log(ary); // [1,2,3,4,5,6]</span><br></pre></td></tr></table></figure>

<ul>
<li>删除最后 n 个元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let ary = [1,2,3,3,5,6]</span><br><span class="line">ary.splice(-2);</span><br><span class="line">console.log(ary); // [1,2,3,4]</span><br></pre></td></tr></table></figure>

<h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h3><p><strong>1.语法</strong></p>
<blockquote>
<p>arr.reverse()</p>
</blockquote>
<p><strong>2.作用</strong></p>
<blockquote>
<p><strong>颠倒数组中元素的位置</strong></p>
</blockquote>
<p><strong>3.参数</strong></p>
<p>无</p>
<p><strong>4.返回值</strong></p>
<blockquote>
<p><strong>颠倒后的数组</strong></p>
</blockquote>
<p><strong>5.实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let ary = [1,2,3,4,5]</span><br><span class="line">ary.reverse();</span><br><span class="line">console.log(ary); // [5,4,3,2,1]</span><br></pre></td></tr></table></figure>

<h3 id="copyWith"><a href="#copyWith" class="headerlink" title="copyWith"></a>copyWith</h3><p><strong>1.语法</strong></p>
<blockquote>
<p>arr.copyWithin(target[, start[, end]])</p>
</blockquote>
<p><strong>2.作用</strong></p>
<blockquote>
<p><strong>复制数组的一部分到同一数组中的另一个位置</strong></p>
</blockquote>
<p><strong>3.参数</strong></p>
<blockquote>
<p>target</p>
<ul>
<li>0 为基底的索引，复制序列到该位置。</li>
<li>如果是负数，target  将从末尾开始计算。</li>
<li>如果  target  大于等于  arr.length，将会不发生拷贝。 -如果  target  在  start  之后，复制 的序列将被修改以符合  arr.length。</li>
</ul>
</blockquote>
<blockquote>
<p>start</p>
<ul>
<li>0 为基底的索引，开始复制元素的起始位置。</li>
<li>如果是负数，start  将从末尾开始计算。</li>
<li>如果  start  被忽略，copyWithin  将会从 0 开始复制。</li>
</ul>
</blockquote>
<blockquote>
<p>end</p>
<ul>
<li>0 为基底的索引，开始复制元素的结束位置。</li>
<li>copyWithin  将会拷贝到该位置，但不包括 end 这个位置的元素。</li>
<li>如果是负数，end 将从末尾开始计算。</li>
<li>如果 end 被忽略，copyWithin 方法将会一直复制至数组结尾（默认为  arr.length）。</li>
</ul>
</blockquote>
<p><strong>4.返回值</strong></p>
<blockquote>
<p><strong>改变后的数组</strong></p>
</blockquote>
<p><strong>5.实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5].copyWithin(-2)         // [1, 2, 3, 1, 2]</span><br><span class="line"></span><br><span class="line">[1, 2, 3, 4, 5].copyWithin(0, 3)       // [4, 5, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">[1, 2, 3, 4, 5].copyWithin(0, 3, 4)    // [4, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">[1, 2, 3, 4, 5].copyWithin(-2, -3, -1) // [1, 2, 3, 3, 4]</span><br></pre></td></tr></table></figure>

<h3 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h3><p><strong>1.语法</strong></p>
<blockquote>
<p>arr.fill(value[, start[, end]])</p>
</blockquote>
<p><strong>2.作用</strong></p>
<blockquote>
<p><strong>用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引</strong></p>
</blockquote>
<p><strong>3.参数</strong></p>
<blockquote>
<p>value<br>用来填充数组元素的值。</p>
</blockquote>
<blockquote>
<p>start （可选）<br>起始索引，默认值为 0。</p>
</blockquote>
<blockquote>
<p>end （可选）<br>终止索引，默认值为 this.length（不包含终止索引）</p>
</blockquote>
<p><strong>4.返回值</strong></p>
<blockquote>
<p><strong>修改后的数组</strong></p>
</blockquote>
<p><strong>5.实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const ary = [1, 2, 3, 4];</span><br><span class="line">console.log(ary.fill(0, 2, 4)); // [1, 2, 0, 0]</span><br><span class="line"></span><br><span class="line">const ary = [1, 2, 3, 4];</span><br><span class="line">console.log(ary.fill(5, 1));    // [1, 5, 5, 5]</span><br><span class="line"></span><br><span class="line">const ary = [1, 2, 3, 4];</span><br><span class="line">console.log(ary.fill(6));       // [6, 6, 6, 6]</span><br></pre></td></tr></table></figure>

<p>省略终止索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const ary = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];</span><br><span class="line">console.log(ary.fill(0, 2)); // [1, 2, 0, 0, 0, 0, 0, 0, 0, 0]</span><br></pre></td></tr></table></figure>

<h2 id="不改变自身值的方法"><a href="#不改变自身值的方法" class="headerlink" title="不改变自身值的方法"></a>不改变自身值的方法</h2><h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><p><strong>1.语法</strong></p>
<blockquote>
<p>var new_array &#x3D; old_array.concat(value1[, value2[, …[, valueN]]])</p>
</blockquote>
<p><strong>2.作用</strong></p>
<blockquote>
<p><strong>合并两个或多个数组</strong></p>
</blockquote>
<p><strong>3.参数</strong></p>
<blockquote>
<p>valueN 可选</p>
<ul>
<li>将数组和&#x2F;或值连接成新数组。</li>
<li>如果省略了 valueN 参数参数，则 concat 会返回一个它所调用的已存在的数组的浅拷贝。</li>
</ul>
</blockquote>
<p><strong>4.返回值</strong></p>
<blockquote>
<p><strong>新的 Array 实例</strong></p>
</blockquote>
<p><strong>5.实例</strong><br>合并两个数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const ary1 = [&#x27;九&#x27;,&#x27;九&#x27;];</span><br><span class="line">const ary2 = [&#x27;欧&#x27;];</span><br><span class="line">let ary3 = ary1.concat(ary2);</span><br><span class="line">console.log(ary3); // [&#x27;九&#x27;,&#x27;九&#x27;,&#x27;欧&#x27;]</span><br></pre></td></tr></table></figure>

<p>合并三个数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const ary1 = [1,2,3];</span><br><span class="line">const ary2 = [4,5,6];</span><br><span class="line">const ary3 = [7,8,9];</span><br><span class="line">let ary4 = ary1.concat(ary2,ary3);</span><br><span class="line">console.log(ary4); // [1,2,3,4,5,6,7,8,9]</span><br></pre></td></tr></table></figure>

<p>将值连接到数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const ary1 = [1,2,3];</span><br><span class="line">const ary2 = [7,8,9];</span><br><span class="line">let ary3 = ary1.concat(4,5,6,ary2);</span><br><span class="line">console.log(ary3); // [1,2,3,4,5,6,7,8,9]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="flat"><a href="#flat" class="headerlink" title="flat"></a>flat</h3><p><strong>1.语法</strong></p>
<blockquote>
<p>var newArray &#x3D; arr.flat([depth])</p>
</blockquote>
<p><strong>2.作用</strong></p>
<blockquote>
<p><strong>将多维数组转化为一维数组</strong></p>
</blockquote>
<p><strong>3.参数</strong></p>
<blockquote>
<p>指定要提取嵌套数组的结构深度，默认值为 1</p>
</blockquote>
<p><strong>4.返回值</strong></p>
<blockquote>
<p><strong>一个包含将数组与子数组中所有元素的新数组</strong></p>
</blockquote>
<p><strong>5.实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  let ary = [1, 2, [3, [4,[5,[6,[7]]]]]];</span><br><span class="line">  console.log(ary.flat());          // [1,2,3,[4,[5,[6,[7]]]]]</span><br><span class="line">  console.log(ary.flat(2));         // [1,2,3,4,[5,[6,[7]]]]</span><br><span class="line">  console.log(ary.flat(3));         // [1,2,3,4,5,[6,[7]]]</span><br><span class="line">// 传入的参数为“Infinity”时，无论是几维数组都会变成1维数组</span><br><span class="line">  console.log(ary.flat(Infinity));  // [1,2,3,4,5,6,7]</span><br></pre></td></tr></table></figure>

<p>flat 方法会移除数组中的空项</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let ary = [1, 2, , 4, 5];</span><br><span class="line">console.log(ary.flat()); // [1, 2, 4, 5]</span><br></pre></td></tr></table></figure>

<h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><p><strong>1.语法</strong></p>
<blockquote>
<p>var new_array &#x3D; arr.flatMap(function callback(currentValue[, index[, array]]) { &#x2F;&#x2F; return element for new_array }[, thisArg])</p>
</blockquote>
<p><strong>2.作用</strong></p>
<blockquote>
<p><strong>使用映射函数映射每个元素，然后将结果压缩成一个新数组</strong></p>
</blockquote>
<p><strong>3.参数</strong></p>
<blockquote>
<p>callback：<br>可以生成一个新数组中元素的函数，包含一下三个参数：<br>currentValue：<br>当前正在数组中处理的元素<br>index(可选)：<br>数组中正在处理的当前元素的索引<br>array：<br>被调用 map 的数组<br>thisAry（可选）：<br>执行 callback 函数值，this 的值</p>
</blockquote>
<p><strong>4.返回值</strong></p>
<blockquote>
<p><strong>新数组</strong></p>
</blockquote>
<p><strong>5.实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let ary = [1, 2, 3, 4];</span><br><span class="line">console.log(ary.flatMap(x =&gt; [x * 2]));    // [2, 4, 6, 8]</span><br><span class="line">console.log(ary.flatMap(x =&gt; [[x * 2]]));  // [[2], [4], [6], [8]]</span><br></pre></td></tr></table></figure>

<p><strong>6.原理</strong><br>先 map()再 flat()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let names = [&#x27;九&#x27;, &#x27;九&#x27;, &#x27;欧&#x27;];</span><br><span class="line">// 步骤 1: map</span><br><span class="line">let result = names.map((name, index) =&gt; [name, index]);</span><br><span class="line">// [ [&#x27;九&#x27;, 1], [&#x27;九&#x27;, 2 ], [&#x27;欧&#x27;，3]]</span><br><span class="line">// 步骤 2: flat</span><br><span class="line">result.flat();</span><br><span class="line">// [ &#x27;九&#x27;, 1, &#x27;九&#x27;, 2 ,&#x27;欧&#x27;,3]</span><br><span class="line"></span><br><span class="line">let names = [&#x27;九&#x27;, &#x27;九&#x27;, &#x27;欧&#x27;];</span><br><span class="line">let result = names.flatMap((name, index) =&gt; [name, index]);</span><br><span class="line">// [ &#x27;九&#x27;, 1, &#x27;九&#x27;, 2 ,&#x27;欧&#x27;,3]</span><br></pre></td></tr></table></figure>

<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p><strong>1.语法</strong></p>
<blockquote>
<p>arr.join([separator])</p>
</blockquote>
<p><strong>2.作用</strong></p>
<blockquote>
<p><strong>将一个数组（或一个类数组对象）的所有元素连接成一个字符</strong></p>
</blockquote>
<p><strong>3.参数</strong></p>
<blockquote>
<p>separator 可选</p>
<ul>
<li>指定一个字符串来分隔数组的每个元素。</li>
<li>如果需要，将分隔符转换为字符串。</li>
<li>如果缺省该值，数组元素用逗号（,）分隔。</li>
<li>如果 separator 是空字符串(“”)，则所有元素 之间都没有任何字符。</li>
</ul>
</blockquote>
<p><strong>4.返回值</strong></p>
<blockquote>
<p><strong>一个所有数组元素连接的字符串。如果 arr.length 为 0，则返回空字符串</strong></p>
</blockquote>
<p><strong>5.实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const ary = [&#x27;九&#x27;, &#x27;九&#x27;, &#x27;欧&#x27;];</span><br><span class="line">let ary = ary.join();       // &quot;九,九,欧&quot;</span><br><span class="line">let ary = ary.join(&#x27;, &#x27;);   // &quot;九, 九, 欧&quot;</span><br><span class="line">let ary = ary.join(&#x27; + &#x27;);  // &quot;九 + 九 + 欧&quot;</span><br><span class="line">let ary = ary.join(&#x27;&#x27;);     // &quot;九九欧&quot;</span><br></pre></td></tr></table></figure>

<p><strong>6.注意事项</strong></p>
<p><strong>如果一个元素为 undefined 或 null，它会被转换为空字符串</strong></p>
<h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><p><strong>1.语法</strong></p>
<blockquote>
<p>arr.slice([begin[, end]])</p>
</blockquote>
<p><strong>2.作用</strong></p>
<blockquote>
<p><strong>将数组中一部分元素浅复制存入新的数组对象</strong></p>
</blockquote>
<p><strong>3.参数</strong></p>
<blockquote>
<p>begin （可选）<br>提取起始处的索引（从  0  开始），从该索引开始提取原数组元素。<br>如果该参数为负数，则表示从原数组中的倒数第几个元素开始提取。<br>slice(-2)  表示提取原数组中的倒数第二个元素到最后一个元素（包含最后一个元素）。<br>如果省略  begin，则  slice  从索引  0  开始。<br>如果  begin  大于原数组的长度，则会返回空数组。</p>
</blockquote>
<blockquote>
<p>end （可选）<br>提取终止处的索引（从  0  开始），在该索引处结束提取原数组元素。<br>slice  会提取原数组中索引从  begin  到  end  的所有元素（包含  begin，但不包含  end）。<br>slice(1,4)  会提取原数组中从第二个元素开始一直到第四个元素的所有元素 （索引 为 1, 2, 3 的元素）。<br>如果该参数为负数，则它表示在原数组中的倒数第几个元素结束抽取。 <br>slice(-2,-1)  表示抽取了原数组中的倒数第二个元素到最后一个元素（不包含最后一个元素，也就是只有倒数第二个元素）。<br>如果  end  被省略，则  slice  会一直提取到原数组末尾。<br>如果  end  大于数组的长度，slice  也会一直提取到原数组末尾。</p>
</blockquote>
<p><strong>4.返回值</strong></p>
<blockquote>
<p><strong>一个含有被提取元素的新数组</strong></p>
</blockquote>
<p><strong>5.实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const ary = [1,2,3,4,5];</span><br><span class="line">console.log(ary.slice(1,4));    // [2,3,4]</span><br><span class="line">console.log(ary.slice(0,100));  // [1,2,3,4,5]</span><br><span class="line">console.log(ary.slice(50,100)); // []</span><br></pre></td></tr></table></figure>

<p><strong>6.应用</strong><br>将类数组转化为数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function fn() &#123;</span><br><span class="line">    return Array.prototype.slice.call(arguments);</span><br><span class="line">&#125;</span><br><span class="line">console.log(fn(1, 2, 3)); // [1, 2, 3]</span><br></pre></td></tr></table></figure>

<h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h3><p><strong>1.语法</strong></p>
<blockquote>
<p>arr.toString()</p>
</blockquote>
<p><strong>2.作用</strong></p>
<blockquote>
<p><strong>返回数组的字符串形式</strong></p>
</blockquote>
<p><strong>3.参数</strong></p>
<p>无</p>
<p><strong>4.返回值</strong></p>
<blockquote>
<p><strong>数组的字符串形式</strong></p>
</blockquote>
<p><strong>5.实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const array = [&#x27;九&#x27;, &#x27;九&#x27;, &#x27;欧&#x27;];</span><br><span class="line">let str = array.toString();</span><br><span class="line">console.log(str);        // 九,九,欧</span><br><span class="line">console.log(typeof str); // string</span><br></pre></td></tr></table></figure>

<h3 id="toLocaleString-NaN"><a href="#toLocaleString-NaN" class="headerlink" title="toLocaleString"></a>toLocaleString</h3><p><strong>1.语法</strong></p>
<blockquote>
<p>arr.toLocaleString([locales[,options]]);</p>
</blockquote>
<p><strong>2.作用</strong></p>
<blockquote>
<p><strong>返回一个字符串表示数组中的元素。数组中的元素将使用各自的 toLocaleString 方法转成字符串，这些字符串将使用一个特定语言环境的字符串（如逗号 “,”）隔开</strong></p>
</blockquote>
<p><strong>3.参数</strong></p>
<blockquote>
<p>locales  可选<br>带有 BCP 47 语言标记的字符串或字符串数组。</p>
</blockquote>
<blockquote>
<p>options  可选<br>一个可配置属性的对象，对于数字  Number.prototype.toLocaleString()<br>对于日期 Date.prototype.toLocaleString().</p>
</blockquote>
<p><strong>4.返回值</strong></p>
<blockquote>
<p><strong>表示数组元素的字符串</strong></p>
</blockquote>
<h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h3><p><strong>1.语法</strong></p>
<blockquote>
<p>arr.indexOf(searchElement[, fromIndex])</p>
</blockquote>
<p><strong>2.作用</strong></p>
<blockquote>
<p><strong>返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1</strong></p>
</blockquote>
<p><strong>3.参数</strong></p>
<blockquote>
<p>searchElement<br>要查找的元素</p>
</blockquote>
<blockquote>
<p>fromIndex  可选<br>开始查找的位置。<br>如果该索引值大于或等于数组长度，意味着不会在数组里查找，返回-1。<br>如果参数中提供的索引值是一个负值，则将其作为数组末尾的一个抵消，即-1 表示从最后一个元素开始查找，-2 表示从倒数第二个元素开始查找，以此类推。<br>注意：如果参数中提供的索引值是一个负值，并不改变其查找顺序，查找顺序仍然是从前向后查询数组。<br>如果抵消后的索引值仍小于 0，则整个数组都将会被 查询。其默认值为 0.</p>
</blockquote>
<p><strong>4.返回值</strong></p>
<blockquote>
<p><strong>首个被找到的元素在数组中的索引位置; 若没有找到则返回 -1</strong></p>
</blockquote>
<p><strong>5.实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const ary = [5,6,7,8,5];</span><br><span class="line">ary.indexOf(5);     // 0</span><br><span class="line">ary.indexOf(1);     // -1</span><br><span class="line">ary.indexOf(5, 2);  // 4</span><br><span class="line">ary.indexOf(5, -2); // 4</span><br></pre></td></tr></table></figure>

<h3 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a>lastIndexOf</h3><p><strong>1.语法</strong></p>
<blockquote>
<p>arr.lastIndexOf(searchElement[, fromIndex])</p>
</blockquote>
<p><strong>2.作用</strong></p>
<blockquote>
<p><strong>查找元素在数组中最后一次出现时的索引，如果没有，则返回-1</strong></p>
</blockquote>
<p><strong>3.参数</strong></p>
<blockquote>
<p>searchElement<br>被查找的元素。</p>
</blockquote>
<blockquote>
<p>fromIndex  可选<br>从此位置开始逆向查找。默认为数组的长度减 1(arr.length - 1)，即整个数组都被查 找。<br>如果该值大于或等于数组的长度，则整个数组会被查找。如果为负值，将其视为从数组末尾向前的偏移。即使该值为负，数组仍然会被从后向前查找。<br>如果该值为负时，其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。</p>
</blockquote>
<p><strong>4.返回值</strong></p>
<blockquote>
<p><strong>数组中该元素最后一次出现的索引，如未找到返回-1</strong></p>
</blockquote>
<p><strong>5.实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const ary = [5, 6, 7, 8, 5];</span><br><span class="line">ary.lastIndexOf(5);     // 4</span><br><span class="line">ary.lastIndexOf(1);     // -1</span><br><span class="line">ary.lastIndexOf(5, 2);  // 0</span><br><span class="line">ary.lastIndexOf(5, -2); // 0</span><br></pre></td></tr></table></figure>

<h3 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h3><p><strong>1.语法</strong></p>
<blockquote>
<p>arr.includes(valueToFind[, fromIndex])</p>
</blockquote>
<p><strong>2.作用</strong></p>
<blockquote>
<p><strong>判断一个数组是否包含一个指定的值</strong></p>
</blockquote>
<p><strong>3.参数</strong></p>
<blockquote>
<p>valueToFind<br>需要查找的元素值。</p>
</blockquote>
<blockquote>
<p>fromIndex  可选<br>从 fromIndex  索引处开始查找  valueToFind。<br>如果为负值，则按升序从  array.length + fromIndex  的索引开始搜<br>（即使从末尾开始往前跳  fromIndex  的绝对值个索引， 然后往后搜寻）默认为 0。</p>
</blockquote>
<p><strong>4.返回值</strong></p>
<blockquote>
<p><strong>布尔值</strong></p>
</blockquote>
<p><strong>5.实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].includes(2);                 // true</span><br><span class="line">[1, 2, 3].includes(4);                 // false</span><br><span class="line">[1, 2, null].includes(null);           // true</span><br><span class="line">[1, 2, undefined].includes(undefined); // true</span><br><span class="line">[1, 2, NaN].includes(NaN);             // true</span><br></pre></td></tr></table></figure>

<p><strong>6.注意事项</strong></p>
<p><strong>使用 includes()比较字符串和字符时区分大小写 includes 方法与 indexOf 方法的功能有些类似，不同点在于 includes 方法可以找到 NaN 而 indexOf 不行</strong></p>
<h3 id="toSource"><a href="#toSource" class="headerlink" title="toSource"></a>toSource</h3><p><strong>1.语法</strong></p>
<blockquote>
<p>array.toSource()</p>
</blockquote>
<p><strong>2.作用</strong></p>
<blockquote>
<p><strong>返回一个代表该数组的源代码的字符串</strong></p>
</blockquote>
<p><strong>3.参数</strong></p>
<p>无</p>
<p><strong>4.返回值</strong></p>
<blockquote>
<p><strong>代表数组源码的字符串</strong></p>
</blockquote>
<p><strong>5.实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var array = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];</span><br><span class="line">console.log(array.toSource()); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tongxinyou.github.io/2022/10/31/js%E5%9F%BA%E7%A1%80-%E7%BB%A7%E6%89%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/tongju.github.io/images/avatar.gif">
      <meta itemprop="name" content="墨白">
      <meta itemprop="description" content="个人技术成长之路">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="墨白的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/tongju.github.io/2022/10/31/js%E5%9F%BA%E7%A1%80-%E7%BB%A7%E6%89%BF/" class="post-title-link" itemprop="url">继承</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tongju.github.io/categories/js%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">js基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="原生-JS-实现继承的-6-种方式"><a href="#原生-JS-实现继承的-6-种方式" class="headerlink" title="原生 JS 实现继承的 6 种方式"></a>原生 JS 实现继承的 6 种方式</h1><ul>
<li>原生 js (ES5) 实现继承的方式 6 种方式：<br>1、通过原型链继承<br>2、借用构造函数继承<br>3、组合继承<br>4、原型式继承<br>5、寄生式继承<br>6、寄生式组合继承</li>
</ul>
<h2 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1.原型链继承"></a>1.原型链继承</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 父类</span><br><span class="line">function SuperType() &#123;</span><br><span class="line">    this.colors = [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;]</span><br><span class="line">&#125;</span><br><span class="line">// 子类</span><br><span class="line">function SubType() &#123; &#125;</span><br><span class="line">SubType.prototype = new SuperType()</span><br><span class="line"></span><br><span class="line">let instance1 = new SubType()</span><br><span class="line">instance1.colors.push(&#x27;black&#x27;)</span><br><span class="line">console.log(instance1.colors)  // &quot;red,blue,green,black&quot;</span><br><span class="line"></span><br><span class="line">let instance2 = new SubType()</span><br><span class="line">console.log(instance2.colors)  // &quot;red,blue,green,black&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>缺点</strong></p>
<ul>
<li>原型上的变量被所有实例共享，当一个实例改变引用类型里面的值时会影响其他实例</li>
<li>不能向父类构造函数传参</li>
</ul>
</blockquote>
<h2 id="2-构造函数继承"><a href="#2-构造函数继承" class="headerlink" title="2.构造函数继承"></a>2.构造函数继承</h2><p>优化了原型链继承共享原型变量的问题，也可以向父类构造函数传参</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 父类</span><br><span class="line">function SuperType(name) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">&#125;</span><br><span class="line">// 子类</span><br><span class="line">function SubType(name1) &#123;</span><br><span class="line">    SuperType.call(this, name1)</span><br><span class="line">    this.age = 28</span><br><span class="line">&#125;</span><br><span class="line">let instance1 = new SubType(&#x27;测试名称&#x27;)</span><br><span class="line">console.log(instance1.name) // 测试名称</span><br><span class="line">console.log(instance1.age) // 28</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>缺点</strong></p>
<ul>
<li>必须在构造函数中定义方法，因此函数不能复用</li>
<li>子类不能访问父类原型上定义的方法</li>
</ul>
</blockquote>
<h2 id="3-组合式继承"><a href="#3-组合式继承" class="headerlink" title="3.组合式继承"></a>3.组合式继承</h2><p>把原型链继承和构造器继承结合起来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = function () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function SubType(name, age) &#123;</span><br><span class="line">    SuperType.call(this, name); // 第二次调用 SuperType()</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = new SuperType(); // 第一次调用 SuperType()</span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = function () &#123;</span><br><span class="line">    console.log(this.age);</span><br><span class="line">&#125;;</span><br><span class="line">let instance1 = new SubType(&quot;Nicholas&quot;, 29);</span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line">console.log(instance1.colors); // &quot;red,blue,green,black&quot;</span><br><span class="line">instance1.sayName(); // &quot;Nicholas&quot;;</span><br><span class="line">instance1.sayAge(); // 29</span><br><span class="line">let instance2 = new SubType(&quot;Greg&quot;, 27);</span><br><span class="line">console.log(instance2.colors); // &quot;red,blue,green&quot;</span><br><span class="line">instance2.sayName(); // &quot;Greg&quot;;</span><br><span class="line">instance2.sayAge(); // 27</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>缺点</strong></p>
<ul>
<li>组合式继承存在效率问题，父类构造函数会被调用两次,第一次是在创建子类原型、第二次是在子类构造函数中调用,最终导致子类原型包含父类所有的实例属性</li>
</ul>
</blockquote>
<h2 id="4-原型继承"><a href="#4-原型继承" class="headerlink" title="4.原型继承"></a>4.原型继承</h2><p>以上是基于函数的继承，现在基于现有的对象继承</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">function object(o) &#123;</span><br><span class="line">	function F() &#123; &#125;</span><br><span class="line">	F.prototype = o</span><br><span class="line">	return new F()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let person = &#123;</span><br><span class="line">	name: &quot;Nicholas&quot;,</span><br><span class="line">	friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]</span><br><span class="line">&#125;;</span><br><span class="line">let anotherPerson = object(person);</span><br><span class="line">anotherPerson.name = &quot;Greg&quot;;</span><br><span class="line">anotherPerson.friends.push(&quot;Rob&quot;);</span><br><span class="line">let yetAnotherPerson = object(person);</span><br><span class="line">yetAnotherPerson.name = &quot;Linda&quot;;</span><br><span class="line">yetAnotherPerson.friends.push(&quot;Barbie&quot;);</span><br><span class="line">console.log(person.friends); // &quot;Shelby,Court,Van,Rob,Barbie&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>缺点</strong></p>
<ul>
<li>属性中包含的引用数值，会在对象之间共享<br>注：ECMAScript 5 通过增加 Object.create()方法将原型式继承的概念规范化了。这个方法接收两个参数：作为新对象原型的对象，以及给新对象定义额外属性的对象（第二个可选）,Object.create()的第二个参数与 Object.defineProperties()的第二个参数一样</li>
</ul>
</blockquote>
<h2 id="5-寄生式继承"><a href="#5-寄生式继承" class="headerlink" title="5.寄生式继承"></a>5.寄生式继承</h2><p>在原型继承的基础上增强</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function createAnother(original) &#123;</span><br><span class="line">    let clone = object(original); // 通过调用函数创建一个新对象</span><br><span class="line">    clone.sayHi = function () &#123; // 以某种方式增强这个对象</span><br><span class="line">            console.log(&quot;hi&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    return clone; // 返回这个对象</span><br><span class="line">&#125;</span><br><span class="line">let person = &#123;</span><br><span class="line">    name: &quot;Nicholas&quot;,</span><br><span class="line">    friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]</span><br><span class="line">&#125;;</span><br><span class="line">let anotherPerson = createAnother(person);</span><br><span class="line">anotherPerson.sayHi(); // &quot;hi&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>缺点</strong></p>
<ul>
<li>给对象添加函数会导致函数难以重用，与构造函数模式类似。</li>
</ul>
</blockquote>
<h2 id="6-寄生组合式继承"><a href="#6-寄生组合式继承" class="headerlink" title="6.寄生组合式继承"></a>6.寄生组合式继承</h2><p>优化了组合继承需要多调一次构造方法的缺点</p>
<p>同时也不会共享父类的变量</p>
<p>也能做到函数的复用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = function () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">function SubType(name, age) &#123;</span><br><span class="line">    SuperType.call(this, name);</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line">SubType.prototype.sayAge = function () &#123;</span><br><span class="line">    console.log(this.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>babel 将 ES6 的 extend 转换成 ES5 代码的时候，使用的就是寄生组合继承</strong></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tongxinyou.github.io/2022/10/29/js%E5%9F%BA%E7%A1%80-es6%E7%9B%B8%E5%85%B3%EF%BC%88%E4%B8%89%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/tongju.github.io/images/avatar.gif">
      <meta itemprop="name" content="墨白">
      <meta itemprop="description" content="个人技术成长之路">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="墨白的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/tongju.github.io/2022/10/29/js%E5%9F%BA%E7%A1%80-es6%E7%9B%B8%E5%85%B3%EF%BC%88%E4%B8%89%EF%BC%89/" class="post-title-link" itemprop="url">ES6相关（三）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tongju.github.io/categories/js%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">js基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="es6-相关特性-（三）"><a href="#es6-相关特性-（三）" class="headerlink" title="es6 相关特性 （三）"></a>es6 相关特性 （三）</h1><h2 id="ES2015"><a href="#ES2015" class="headerlink" title="ES2015"></a>ES2015</h2><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><ul>
<li>命令<ul>
<li>export：规定模块对外接口<ul>
<li>默认导出：export default Person(导入时可指定模块任意名称，无需知晓内部真实名称)</li>
<li>单独导出：export const name &#x3D; “Bruce”</li>
<li>按需导出：export { age, name, sex }(推荐)</li>
<li>改名导出：export { name as newName }</li>
</ul>
</li>
<li>import：导入模块内部功能<ul>
<li>默认导入：import Person from “person”</li>
<li>整体导入：import * as Person from “person”</li>
<li>按需导入：import { age, name, sex } from “person”</li>
<li>改名导入：import { name as newName } from “person”</li>
<li>自执导入：import “person”</li>
<li>复合导入：import Person, { name } from “person”</li>
</ul>
</li>
<li>复合模式：export 命令和 import 命令结合在一起写成一行，变量实质没有被导入当前模块，相当于对外转发接口，导致当前模块无法直接使用其导入变量<ul>
<li>默认导入导出：export { default } from “person”</li>
<li>整体导入导出：export * from “person”</li>
<li>按需导入导出：export { age, name, sex } from “person”</li>
<li>改名导入导出：export { name as newName } from “person”</li>
<li>具名改默认导入导出：export { name as default } from “person”</li>
<li>默认改具名导入导出：export { default as name } from “person”</li>
</ul>
</li>
</ul>
</li>
<li>继承：默认导出和改名导出结合使用可使模块具备继承性</li>
<li>设计思想：尽量地静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量</li>
<li>严格模式：ES6 模块自动采用严格模式(不管模块头部是否添加 use strict)</li>
</ul>
<blockquote>
<p><strong>模块方案</strong></p>
<ul>
<li>CommonJS：用于服务器(动态化依赖)</li>
<li>AMD：用于浏览器(动态化依赖)</li>
<li>CMD：用于浏览器(动态化依赖)</li>
<li>UMD：用于浏览器和服务器(动态化依赖)</li>
<li>ESM：用于浏览器和服务器(静态化依赖)</li>
</ul>
</blockquote>
<blockquote>
<p><strong>加载方式</strong></p>
<ul>
<li>运行时加载<ul>
<li>定义：整体加载模块生成一个对象，再从对象上获取需要的属性和方法进行加载(全部加载)</li>
<li>影响：只有运行时才能得到这个对象，导致无法在编译时做静态优化</li>
</ul>
</li>
<li>编译时加载<ul>
<li>定义：直接从模块中获取需要的属性和方法进行加载(按需加载)</li>
<li>影响：在编译时就完成模块加载，效率比其他方案高，但无法引用模块本身(本身不是对象)，可拓展 JS 高级语法(宏和类型校验)</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p><strong>加载实现</strong></p>
<ul>
<li>传统加载：通过&lt;script&gt;进行同步或异步加载脚本<ul>
<li>同步加载：&lt;script src&#x3D;””&gt;&lt;&#x2F;script&gt;</li>
<li>Defer 异步加载：&lt;script src&#x3D;”” defer&gt;&lt;&#x2F;script&gt;(顺序加载，渲染完再执行)</li>
<li>Async 异步加载：&lt;script src&#x3D;”” async&gt;&lt;&#x2F;script&gt;(乱序加载，下载完就执行)</li>
</ul>
</li>
<li>模块加载：&lt;script type&#x3D;”module” src&#x3D;””&gt;&lt;&#x2F;script&gt;(默认是 Defer 异步加载)</li>
</ul>
</blockquote>
<blockquote>
<p><strong>CommonJS 和 ESM 的区别</strong></p>
<ul>
<li>CommonJS 输出值的拷贝，ESM 输出值的引用<ul>
<li>CommonJS 一旦输出一个值，模块内部的变化就影响不到这个值</li>
<li>ESM 是动态引用且不会缓存值，模块里的变量绑定其所在的模块，等到脚本真正执行时，再根据这个只读引用到被加载的那个模块里去取值</li>
</ul>
</li>
<li>CommonJS 是运行时加载，ESM 是编译时加载<ul>
<li>CommonJS 加载模块是对象(即 module.exports)，该对象只有在脚本运行完才会生成</li>
<li>ESM 加载模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p><strong>Node 加载</strong></p>
<ul>
<li>背景：CommonJS 和 ESM 互不兼容，目前解决方案是将两者分开，采用各自的加载方案</li>
<li>区分：要求 ESM 采用.mjs 后缀文件名<ul>
<li>require()不能加载.mjs 文件，只有 import 命令才可加载.mjs 文件</li>
<li>.mjs 文件里不能使用 require()，必须使用 import 命令加载文件</li>
</ul>
</li>
<li>驱动：node –experimental-modules file.mjs</li>
<li>限制：Node 的 import 命令目前只支持加载本地模块(file:协议)，不支持加载远程模块</li>
<li>加载优先级<ul>
<li>脚本文件省略后缀名：依次尝试加载四个后缀名文件(.mjs、.js、.json、node)</li>
<li>以上不存在：尝试加载 package.json 的 main 字段指定的脚本</li>
<li>以上不存在：依次尝试加载名称为 index 四个后缀名文件(.mjs、.js、.json、node)</li>
<li>以上不存在：报错</li>
</ul>
</li>
<li>不存在的内部变量：arguments、exports、module、require、this、_dirname、_filename</li>
<li>CommonJS 加载 ESM<ul>
<li>不能使用 require()，只能使用 import()</li>
</ul>
</li>
<li>ESM 加载 CommonJS<ul>
<li>自动将 module.exports 转化成 export default</li>
<li>CommonJS 输出缓存机制在 ESM 加载方式下依然有效</li>
<li>采用 import 命令加载 CommonJS 模块时，不允许采用按需导入，应使用默认导入或整体导入</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p><strong>循环加载</strong></p>
<ul>
<li>定义：脚本 A 的执行依赖脚本 B，而脚本 A 的执行又依赖脚本 B</li>
<li>加载原理<ul>
<li>CommonJS：require()首次加载脚本就会执行整个脚本，在内存里生成一个对象缓存下来，二次加载脚本时直接从缓存中获取</li>
<li>ESM：import 命令加载变量不会被缓存，而是成为一个指向被加载模块的引用</li>
</ul>
</li>
<li>循环加载<ul>
<li>CommonJS：只输出已经执行的部分，还未执行的部分不会输出</li>
<li>ESM：需开发者自己保证真正取值时能够取到值(可把变量写成函数形式，函数具有提升作用)</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p><strong>重难点</strong></p>
<ul>
<li>ES6 模块中，顶层 this 指向 undefined，不应该在顶层代码使用 this</li>
<li>一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取</li>
<li>export 命令输出的接口与其对应的值是动态绑定关系，即通过该接口可获取模块内部实时的值</li>
<li>import 命令大括号里的变量名必须与被导入模块对外接口的名称相同</li>
<li>import 命令输入的变量只读(本质是输入接口)，不允许在加载模块的脚本里改写接口</li>
<li>import 命令命令具有提升效果，会提升到整个模块的头部，首先执行</li>
<li>重复执行同一句 import 语句，只会执行一次</li>
<li>export default 命令只能使用一次</li>
<li>export default 命令导出的整体模块，在执行 import 命令时其后不能跟大括号</li>
<li>export default 命令本质是输出一个名为 default 的变量，后面不能跟变量声明语句</li>
<li>export default 命令本质是将后面的值赋给名为 default 的变量，可直接将值写在其后</li>
<li>export default 命令和 export {}命令可同时存在，对应复合导入</li>
<li>export 命令和 import 命令可出现在模块任何位置，只要处于模块顶层即可，不能处于块级作用域</li>
<li>import()加载模块成功后，此模块会作为一个对象，当作 then()的参数，可使用对象解构赋值来获取输出接口</li>
<li>同时动态加载多个模块时，可使用 Promise.all()和 import()相结合来实现</li>
<li>import()和结合 async&#x2F;await 来书写同步操作的代码</li>
</ul>
</blockquote>
<ul>
<li><strong>单例模式：跨模块常量</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 常量跨文件共享</span><br><span class="line">// person.js</span><br><span class="line">const NAME = &quot;Bruce&quot;;</span><br><span class="line">const AGE = 25;</span><br><span class="line">const SEX = &quot;male&quot;;</span><br><span class="line">export &#123; AGE, NAME, SEX &#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// file1.js</span><br><span class="line">import &#123; AGE &#125; from &quot;person&quot;;</span><br><span class="line">console.log(AGE);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// file2.js</span><br><span class="line">import &#123; AGE, NAME, SEX &#125; from &quot;person&quot;;</span><br><span class="line">console.log(AGE, NAME, SEX);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>默认导入互换整体导入</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import Person from &quot;person&quot;;</span><br><span class="line">console.log(Person.AGE);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import * as Person from &quot;person&quot;;</span><br><span class="line">console.log(Person.default.AGE);</span><br></pre></td></tr></table></figure>

<h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><ul>
<li>定义：为各种不同的数据结构提供统一的访问机制</li>
<li>原理：创建一个指针指向首个成员，按照次序使用 next()指向下一个成员，直接到结束位置(数据结构只要部署 Iterator 接口就可完成遍历操作)</li>
<li>作用<ul>
<li>为各种数据结构提供一个统一的简便的访问接口</li>
<li>使得数据结构成员能够按某种次序排列</li>
<li>ES6 创造了新的遍历命令 for-of，Iterator 接口主要供 for-of 消费</li>
</ul>
</li>
<li>形式：for-of(自动去寻找 Iterator 接口)</li>
<li>数据结构<ul>
<li>集合：Array、Object、Set、Map</li>
<li>原生具备接口的数据结构：String、Array、Set、Map、TypedArray、Arguments、NodeList</li>
</ul>
</li>
<li>部署：默认部署在 Symbol.iterator(具备此属性被认为可遍历的 iterable)</li>
<li>遍历器对象<ul>
<li>next()：下一步操作，返回{ done, value }(必须部署)</li>
<li>return()：for-of 提前退出调用，返回{ done: true }</li>
<li>throw()：不使用，配合 Generator 函数使用</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>ForOf 循环</strong></p>
<ul>
<li>定义：调用 Iterator 接口产生遍历器对象(for-of 内部调用数据结构的 Symbol.iterator())</li>
<li>遍历字符串：for-in 获取索引，for-of 获取值(可识别 32 位 UTF-16 字符)</li>
<li>遍历数组：for-in 获取索引，for-of 获取值</li>
<li>遍历对象：for-in 获取键，for-of 需自行部署</li>
<li>遍历 Set：for-of 获取值 &#x3D;&gt; for (const v of set)</li>
<li>遍历 Map：for-of 获取键值对 &#x3D;&gt; for (const [k, v] of map)</li>
<li>遍历类数组：包含 length 的对象、Arguments 对象、NodeList 对象(无 Iterator 接口的类数组可用 Array.from()转换)</li>
<li>计算生成数据结构：Array、Set、Map<ul>
<li>keys()：返回遍历器对象，遍历所有的键</li>
<li>values()：返回遍历器对象，遍历所有的值</li>
<li>entries()：返回遍历器对象，遍历所有的键值对</li>
</ul>
</li>
<li>与 for-in 区别<ul>
<li>有着同 for-in 一样的简洁语法，但没有 for-in 那些缺点、</li>
<li>不同于 forEach()，它可与 break、continue 和 return 配合使用</li>
<li>提供遍历所有数据结构的统一操作接口</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p><strong>应用场景</strong></p>
<ul>
<li>改写具有 Iterator 接口的数据结构的 Symbol.iterator</li>
<li>解构赋值：对 Set 进行结构</li>
<li>扩展运算符：将部署 Iterator 接口的数据结构转为数组</li>
<li>yield<em>：yield</em>后跟一个可遍历的数据结构，会调用其遍历器接口</li>
<li>接受数组作为参数的函数：for-of、Array.from()、new Set()、new WeakSet()、new Map()、new WeakMap()、Promise.all()、Promise.race()</li>
</ul>
</blockquote>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><ul>
<li><p>定义：包含异步操作结果的对象</p>
</li>
<li><p>状态</p>
<ul>
<li>进行中：pending</li>
<li>已成功：resolved</li>
<li>已失败：rejected</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li>对象的状态不受外界影响</li>
<li>一旦状态改变就不会再变，任何时候都可得到这个结果</li>
</ul>
</li>
<li><p>声明：new Promise((resolve, reject) &#x3D;&gt; {})</p>
</li>
<li><p>出参</p>
<ul>
<li>resolve：将状态从未完成变为成功，在异步操作成功时调用，并将异步操作的结果作为参数传递出去</li>
<li>reject：将状态从未完成变为失败，在异步操作失败时调用，并将异步操作的错误作为参数传递出去</li>
</ul>
</li>
<li><p>方法</p>
<ul>
<li>then()：分别指定 resolved 状态和 rejected 状态的回调函数<ul>
<li>第一参数：状态变为 resolved 时调用</li>
<li>第二参数：状态变为 rejected 时调用(可选)</li>
</ul>
</li>
<li>catch()：指定发生错误时的回调函数</li>
<li>Promise.all()：将多个实例包装成一个新实例，返回全部实例状态变更后的结果数组(齐变更再返回)<ul>
<li>入参：具有 Iterator 接口的数据结构</li>
<li>成功：只有全部实例状态变成 fulfilled，最终状态才会变成 fulfilled</li>
<li>失败：其中一个实例状态变成 rejected，最终状态就会变成 rejected</li>
</ul>
</li>
<li>Promise.race()：将多个实例包装成一个新实例，返回全部实例状态优先变更后的结果(先变更先返回)<ul>
<li>入参：具有 Iterator 接口的数据结构</li>
<li>成功失败：哪个实例率先改变状态就返回哪个实例的状态</li>
</ul>
</li>
<li>Promise.resolve()：将对象转为 Promise 对象(等价于 new Promise(resolve &#x3D;&gt; resolve()))<ul>
<li>Promise 实例：原封不动地返回入参</li>
<li>Thenable 对象：将此对象转为 Promise 对象并返回(Thenable 为包含 then()的对象，执行 then()相当于执行此对象的 then())</li>
<li>不具有 then()的对象：将此对象转为 Promise 对象并返回，状态为 resolved</li>
<li>不带参数：返回 Promise 对象，状态为 resolved</li>
</ul>
</li>
<li>Promise.reject()：将对象转为状态为 rejected 的 Promise 对象(等价于 new Promise((resolve, reject) &#x3D;&gt; reject()))</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>应用场景</strong><br>加载图片<br>AJAX 转 Promise 对象</p>
</blockquote>
<blockquote>
<p><strong>重难点</strong></p>
<ul>
<li>只有异步操作的结果可决定当前状态是哪一种，其他操作都无法改变这个状态</li>
<li>状态改变只有两种可能：从 pending 变为 resolved、从 pending 变为 rejected</li>
<li>一旦新建 Promise 对象就会立即执行，无法中途取消</li>
<li>不设置回调函数，内部抛错不会反应到外部</li>
<li>当处于 pending 时，无法得知目前进展到哪一个阶段</li>
<li>实例状态变为 resolved 或 rejected 时，会触发 then()绑定的回调函数</li>
<li>resolve()和 reject()的执行总是晚于本轮循环的同步任务</li>
<li>then()返回新实例，其后可再调用另一个 then()</li>
<li>then()运行中抛出错误会被 catch()捕获</li>
<li>reject()的作用等同于抛出错误</li>
<li>实例状态已变成 resolved 时，再抛出错误是无效的，不会被捕获，等于没有抛出</li>
<li>实例状态的错误具有冒泡性质，会一直向后传递直到被捕获为止，错误总是会被下一个 catch()捕获</li>
<li>不要在 then()里定义 rejected 状态的回调函数(不使用其第二参数)</li>
<li>建议使用 catch()捕获错误，不要使用 then()第二个参数捕获</li>
<li>没有使用 catch()捕获错误，实例抛错不会传递到外层代码，即不会有任何反应</li>
<li>作为参数的实例定义了 catch()，一旦被 rejected 并不会触发 Promise.all()的 catch()</li>
<li>Promise.reject()的参数会原封不动地作为 rejected 的理由，变成后续方法的参数</li>
</ul>
</blockquote>
<h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><ul>
<li>定义：封装多个内部状态的异步编程解决方案</li>
<li>形式：调用 Generator 函数(该函数不执行)返回指向内部状态的指针对象(不是运行结果)</li>
<li>声明：function* Func() {}</li>
<li>方法<ul>
<li>next()：使指针移向下一个状态，返回{ done, value }(入参会被当作上一个 yield 命令表达式的返回值)</li>
<li>return()：返回指定值且终结遍历 Generator 函数，返回{ done: true, value: 入参 }</li>
<li>throw()：在 Generator 函数体外抛出错误，在 Generator 函数体内捕获错误，返回自定义的 new Errow()</li>
</ul>
</li>
<li>yield 命令：声明内部状态的值(return 声明结束返回的值)<ul>
<li>遇到 yield 命令就暂停执行后面的操作，并将其后表达式的值作为返回对象的 value</li>
<li>下次调用 next()时，再继续往下执行直到遇到下一个 yield 命令</li>
<li>没有再遇到 yield 命令就一直运行到 Generator 函数结束，直到遇到 return 语句为止并将其后表达式的值作为返回对象的 value</li>
<li>Generator 函数没有 return 语句则返回对象的 value 为 undefined</li>
</ul>
</li>
<li>yield*命令：在一个 Generator 函数里执行另一个 Generator 函数(后随具有 Iterator 接口的数据结构)</li>
<li>遍历：通过 for-of 自动调用 next()</li>
<li>作为对象属性<ul>
<li>全写：const obj &#x3D; { method: function*() {} }</li>
<li>简写：const obj &#x3D; { * method() {} }</li>
</ul>
</li>
<li>上下文：执行产生的上下文环境一旦遇到 yield 命令就会暂时退出堆栈(但并不消失)，所有变量和对象会冻结在当前状态，等到对它执行 next()时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行</li>
</ul>
<blockquote>
<p><strong>方法异同</strong></p>
<ul>
<li>相同点：next()、throw()、return()本质上是同一件事，作用都是让函数恢复执行且使用不同的语句替换 yield 命令</li>
<li>不同点<ul>
<li>next()：将 yield 命令替换成一个值</li>
<li>return()：将 yield 命令替换成一个 return 语句</li>
<li>throw()：将 yield 命令替换成一个 throw 语句</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p><strong>应用场景</strong></p>
<ul>
<li>异步操作同步化表达</li>
<li>控制流管理</li>
<li>为对象部署 Iterator 接口：把 Generator 函数赋值给对象的 Symbol.iterator，从而使该对象具有 Iterator 接口</li>
<li>作为具有 Iterator 接口的数据结构</li>
</ul>
</blockquote>
<blockquote>
<p><strong>重难点</strong></p>
<ul>
<li>每次调用 next()，指针就从函数头部或上次停下的位置开始执行，直到遇到下一个 yield 命令或 return 语句为止</li>
<li>函数内部可不用 yield 命令，但会变成单纯的暂缓执行函数(还是需要 next()触发)</li>
<li>yield 命令是暂停执行的标记，next()是恢复执行的操作</li>
<li>yield 命令用在另一个表达式中必须放在圆括号里</li>
<li>yield 命令用作函数参数或放在赋值表达式的右边，可不加圆括号</li>
<li>yield 命令本身没有返回值，可认为是返回 undefined</li>
<li>yield 命令表达式为惰性求值，等 next()执行到此才求值</li>
<li>函数调用后生成遍历器对象，此对象的 Symbol.iterator 是此对象本身</li>
<li>在函数运行的不同阶段，通过 next()从外部向内部注入不同的值，从而调整函数行为</li>
<li>首个 next()用来启动遍历器对象，后续才可传递参数</li>
<li>想首次调用 next()时就能输入值，可在函数外面再包一层</li>
<li>一旦 next()返回对象的 done 为 true，for-of 遍历会中止且不包含该返回对象</li>
<li>函数内部部署 try-finally 且正在执行 try，那么 return()会导致立刻进入 finally，执行完 finally 以后整个函数才会结束</li>
<li>函数内部没有部署 try-catch，throw()抛错将被外部 try-catch 捕获</li>
<li>throw()抛错要被内部捕获，前提是必须至少执行过一次 next()</li>
<li>throw()被捕获以后，会附带执行下一条 yield 命令</li>
<li>函数还未开始执行，这时 throw()抛错只可能抛出在函数外部</li>
</ul>
</blockquote>
<blockquote>
<p><strong>首次 next()可传值</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Wrapper(func) &#123;</span><br><span class="line">    return function(...args) &#123;</span><br><span class="line">        const generator = func(...args);</span><br><span class="line">        generator.next();</span><br><span class="line">        return generator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const print = Wrapper(function*() &#123;</span><br><span class="line">    console.log(`First Input: $&#123;yield&#125;`);</span><br><span class="line">    return &quot;done&quot;;</span><br><span class="line">&#125;);</span><br><span class="line">print().next(&quot;hello&quot;);</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tongxinyou.github.io/2022/10/29/js%E5%9F%BA%E7%A1%80-es6%E7%9B%B8%E5%85%B3%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/tongju.github.io/images/avatar.gif">
      <meta itemprop="name" content="墨白">
      <meta itemprop="description" content="个人技术成长之路">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="墨白的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/tongju.github.io/2022/10/29/js%E5%9F%BA%E7%A1%80-es6%E7%9B%B8%E5%85%B3%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">ES6相关（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tongju.github.io/categories/js%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">js基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="es6-相关特性-（二）"><a href="#es6-相关特性-（二）" class="headerlink" title="es6 相关特性 （二）"></a>es6 相关特性 （二）</h1><h2 id="ES2015"><a href="#ES2015" class="headerlink" title="ES2015"></a>ES2015</h2><h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><ul>
<li><p>定义：独一无二的值</p>
</li>
<li><p>声明：const set &#x3D; Symbol(str)</p>
</li>
<li><p>入参：字符串(可选)</p>
</li>
<li><p>方法</p>
<ul>
<li>Symbol()：创建以参数作为描述的 Symbol 值(不登记在全局环境)</li>
<li>Symbol.for()：创建以参数作为描述的 Symbol 值，如存在此参数则返回原有的 Symbol 值(先搜索后创建，登记在全局环境)</li>
<li>Symbol.keyFor()：返回已登记的 Symbol 值的描述(只能返回 Symbol.for()的 key)</li>
<li>Object.getOwnPropertySymbols()：返回对象中所有用作属性名的 Symbol 值的数组</li>
</ul>
</li>
<li><p>内置</p>
<ul>
<li>Symbol.hasInstance：指向一个内部方法，当其他对象使用 instanceof 运算符判断是否为此对象的实例时会调用此方法</li>
<li>Symbol.isConcatSpreadable：指向一个布尔，定义对象用于 Array.prototype.concat()时是否可展开</li>
<li>Symbol.species：指向一个构造函数，当实例对象使用自身构造函数时会调用指定的构造函数</li>
<li>Symbol.match：指向一个函数，当实例对象被 String.prototype.match()调用时会重新定义 match()的行为</li>
<li>Symbol.replace：指向一个函数，当实例对象被 String.prototype.replace()调用时会重新定义 replace()的行为</li>
<li>Symbol.search：指向一个函数，当实例对象被 String.prototype.search()调用时会重新定义 search()的行为</li>
<li>Symbol.split：指向一个函数，当实例对象被 String.prototype.split()调用时会重新定义 split()的行为</li>
<li>Symbol.iterator：指向一个默认遍历器方法，当实例对象执行 for-of 时会调用指定的默认遍历器</li>
<li>Symbol.toPrimitive：指向一个函数，当实例对象被转为原始类型的值时会返回此对象对应的原始类型值</li>
<li>Symbol.toStringTag：指向一个函数，当实例对象被 Object.prototype.toString()调用时其返回值会出现在 toString()返回的字符串之中表示对象的类型</li>
<li>Symbol.unscopables：指向一个对象，指定使用 with 时哪些属性会被 with 环境排除</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>数据类型:</strong></p>
<ul>
<li>Undefined</li>
<li>Null</li>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>Object(包含 Array、Function、Date、RegExp、Error)</li>
<li>Symbol</li>
</ul>
</blockquote>
<blockquote>
<p><strong>应用场景</strong></p>
<ul>
<li>唯一化对象属性名：属性名属于 Symbol 类型，就都是独一无二的，可保证不会与其他属性名产生冲突</li>
<li>消除魔术字符串：在代码中多次出现且与代码形成强耦合的某一个具体的字符串或数值</li>
<li>遍历属性名：无法通过 for-in、for-of、Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回，只能通过 Object.getOwnPropertySymbols 返回</li>
<li>启用模块的 Singleton 模式：调用一个类在任何时候返回同一个实例(window 和 global)，使用 Symbol.for()来模拟全局的 Singleton 模式</li>
</ul>
</blockquote>
<blockquote>
<p><strong>重难点</strong></p>
<ul>
<li>Symbol()生成一个原始类型的值不是对象，因此 Symbol()前不能使用 new 命令</li>
<li>Symbol()参数表示对当前 Symbol 值的描述，相同参数的 Symbol()返回值不相等</li>
<li>Symbol 值不能与其他类型的值进行运算</li>
<li>Symbol 值可通过 String()或 toString()显式转为字符串</li>
<li>Symbol 值作为对象属性名时，此属性是公开属性，但不是私有属性</li>
<li>Symbol 值作为对象属性名时，只能用方括号运算符([])读取，不能用点运算符(.)读取</li>
<li>Symbol 值作为对象属性名时，不会被常规方法遍历得到，可利用此特性为对象定义非私有但又只用于内部的方法</li>
</ul>
</blockquote>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="Set-1"><a href="#Set-1" class="headerlink" title="Set"></a>Set</h4><ul>
<li>定义：类似于数组的数据结构，成员值都是唯一且没有重复的值</li>
<li>声明：const set &#x3D; new Set(arr)</li>
<li>入参：具有 Iterator 接口的数据结构</li>
<li>属性<ul>
<li>constructor：构造函数，返回 Set</li>
<li>size：返回实例成员总数</li>
</ul>
</li>
<li>方法<ul>
<li>add()：添加值，返回实例</li>
<li>delete()：删除值，返回布尔</li>
<li>has()：检查值，返回布尔</li>
<li>clear()：清除所有成员</li>
<li>keys()：返回以属性值为遍历器的对象</li>
<li>values()：返回以属性值为遍历器的对象</li>
<li>entries()：返回以属性值和属性值为遍历器的对象</li>
<li>forEach()：使用回调函数遍历每个成员</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>应用场景</strong></p>
<ul>
<li>去重字符串：[…new Set(str)].join(“”)</li>
<li>去重数组：[…new Set(arr)]或 Array.from(new Set(arr))</li>
<li>集合数组<ul>
<li>声明：const a &#x3D; new Set(arr1)、const b &#x3D; new Set(arr2)</li>
<li>并集：new Set([…a, …b])</li>
<li>交集：new Set([…a].filter(v &#x3D;&gt; b.has(v)))</li>
<li>差集：new Set([…a].filter(v &#x3D;&gt; !b.has(v)))</li>
</ul>
</li>
<li>映射集合<ul>
<li>声明：let set &#x3D; new Set(arr)</li>
<li>映射：set &#x3D; new Set([…set].map(v &#x3D;&gt; v _ 2))或 set &#x3D; new Set(Array.from(set, v &#x3D;&gt; v _ 2))</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p><strong>重难点</strong></p>
<ul>
<li>遍历顺序：插入顺序</li>
<li>没有键只有值，可认为键和值两值相等</li>
<li>添加多个 NaN 时，只会存在一个 NaN</li>
<li>添加相同的对象时，会认为是不同的对象</li>
<li>添加值时不会发生类型转换(5 !&#x3D;&#x3D; “5”)</li>
<li>keys()和 values()的行为完全一致，entries()返回的遍历器同时包括键和值且两值相等</li>
</ul>
</blockquote>
<h4 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h4><ul>
<li>定义：和 Set 结构类似，成员值只能是对象</li>
<li>声明：const set &#x3D; new WeakSet(arr)</li>
<li>入参：具有 Iterator 接口的数据结构</li>
<li>属性<ul>
<li>constructor：构造函数，返回 WeakSet</li>
</ul>
</li>
<li>方法<ul>
<li>add()：添加值，返回实例</li>
<li>delete()：删除值，返回布尔</li>
<li>has()：检查值，返回布尔</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>应用场景</strong></p>
<ul>
<li>储存 DOM 节点：DOM 节点被移除时自动释放此成员，不用担心这些节点从文档移除时会引发内存泄漏</li>
<li>临时存放一组对象或存放跟对象绑定的信息：只要这些对象在外部消失，它在 WeakSet 结构中的引用就会自动消</li>
</ul>
</blockquote>
<blockquote>
<p><strong>重难点</strong></p>
<ul>
<li>成员都是弱引用，垃圾回收机制不考虑 WeakSet 结构对此成员的引用</li>
<li>成员不适合引用，它会随时消失，因此 ES6 规定 WeakSet 结构不可遍历</li>
<li>其他对象不再引用成员时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于 WeakSet 结构中</li>
</ul>
</blockquote>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h4><ul>
<li>定义：类似于对象的数据结构，成员键是任何类型的值</li>
<li>声明：const set &#x3D; new Map(arr)</li>
<li>入参：具有 Iterator 接口且每个成员都是一个双元素数组的数据结构</li>
<li>属性<ul>
<li>constructor：构造函数，返回 Map</li>
<li>size：返回实例成员总数</li>
</ul>
</li>
<li>方法<ul>
<li>get()：返回键值对</li>
<li>set()：添加键值对，返回实例</li>
<li>delete()：删除键值对，返回布尔</li>
<li>has()：检查键值对，返回布尔</li>
<li>clear()：清除所有成员</li>
<li>keys()：返回以键为遍历器的对象</li>
<li>values()：返回以值为遍历器的对象</li>
<li>entries()：返回以键和值为遍历器的对象</li>
<li>forEach()：使用回调函数遍历每个成员</li>
</ul>
</li>
</ul>
<blockquote>
<p>重难点</p>
<ul>
<li>遍历顺序：插入顺序</li>
<li>对同一个键多次赋值，后面的值将覆盖前面的值</li>
<li>对同一个对象的引用，被视为一个键</li>
<li>对同样值的两个实例，被视为两个键</li>
<li>键跟内存地址绑定，只要内存地址不一样就视为两个键</li>
<li>添加多个以 NaN 作为键时，只会存在一个以 NaN 作为键的值</li>
<li>Object 结构提供字符串—值的对应，Map 结构提供值—值的对应</li>
</ul>
</blockquote>
<h4 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h4><ul>
<li>定义：和 Map 结构类似，成员键只能是对象</li>
<li>声明：const set &#x3D; new WeakMap(arr)</li>
<li>入参：具有 Iterator 接口且每个成员都是一个双元素数组的数据结构</li>
<li>属性<ul>
<li>constructor：构造函数，返回 WeakMap</li>
</ul>
</li>
<li>方法<ul>
<li>get()：返回键值对</li>
<li>set()：添加键值对，返回实例</li>
<li>delete()：删除键值对，返回布尔</li>
<li>has()：检查键值对，返回布尔</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>应用场景</strong></p>
<ul>
<li>储存 DOM 节点：DOM 节点被移除时自动释放此成员键，不用担心这些节点从文档移除时会引发内存泄漏</li>
<li>部署私有属性：内部属性是实例的弱引用，删除实例时它们也随之消失，不会造成内存泄漏</li>
</ul>
</blockquote>
<blockquote>
<p>重难点</p>
<ul>
<li>成员键都是弱引用，垃圾回收机制不考虑 WeakMap 结构对此成员键的引用</li>
<li>成员键不适合引用，它会随时消失，因此 ES6 规定 WeakMap 结构不可遍历</li>
<li>其他对象不再引用成员键时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于 WeakMap 结构中</li>
<li>一旦不再需要，成员会自动消失，不用手动删除引用</li>
<li>弱引用的只是键而不是值，值依然是正常引用</li>
<li>即使在外部消除了成员键的引用，内部的成员值依然存在</li>
</ul>
</blockquote>
<h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><ul>
<li>定义：修改某些操作的默认行为</li>
<li>声明：const proxy &#x3D; new Proxy(target, handler)</li>
<li>入参<ul>
<li>target：拦截的目标对象</li>
<li>handler：定制拦截行为</li>
</ul>
</li>
<li>方法<ul>
<li>Proxy.revocable()：返回可取消的 Proxy 实例(返回{ proxy, revoke }，通过 revoke()取消代理)</li>
</ul>
</li>
<li>拦截方式<ul>
<li>get()：拦截对象属性读取</li>
<li>set()：拦截对象属性设置，返回布尔</li>
<li>has()：拦截对象属性检查 k in obj，返回布尔</li>
<li>deleteProperty()：拦截对象属性删除 delete obj[k]，返回布尔</li>
<li>defineProperty()：拦截对象属性定义 Object.defineProperty()、Object.defineProperties()，返回布尔</li>
<li>ownKeys()：拦截对象属性遍历 for-in、Object.keys()、Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()，返回数组</li>
<li>getOwnPropertyDescriptor()：拦截对象属性描述读取 Object.getOwnPropertyDescriptor()，返回对象</li>
<li>getPrototypeOf()：拦截对象原型读取 instanceof、Object.getPrototypeOf()、Object.prototype.<strong>proto</strong>、Object.prototype.isPrototypeOf()、Reflect.getPrototypeOf()，返回对象</li>
<li>setPrototypeOf()：拦截对象原型设置 Object.setPrototypeOf()，返回布尔</li>
<li>isExtensible()：拦截对象是否可扩展读取 Object.isExtensible()，返回布尔</li>
<li>preventExtensions()：拦截对象不可扩展设置 Object.preventExtensions()，返回布尔</li>
<li>apply()：拦截 Proxy 实例作为函数调用 proxy()、proxy.apply()、proxy.call()</li>
<li>construct()：拦截 Proxy 实例作为构造函数调用 new proxy()</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>应用场景</strong></p>
<ul>
<li>Proxy.revocable()：不允许直接访问对象，必须通过代理访问，一旦访问结束就收回代理权不允许再次访问</li>
<li>get()：读取未知属性报错、读取数组负数索引的值、封装链式操作、生成 DOM 嵌套节点</li>
<li>set()：数据绑定(Vue 数据绑定实现原理)、确保属性值设置符合要求、防止内部属性被外部读写</li>
<li>has()：隐藏内部属性不被发现、排除不符合属性条件的对象</li>
<li>deleteProperty()：保护内部属性不被删除</li>
<li>defineProperty()：阻止属性被外部定义</li>
<li>ownKeys()：保护内部属性不被遍历</li>
</ul>
</blockquote>
<blockquote>
<p>重难点</p>
<ul>
<li>要使 Proxy 起作用，必须针对实例进行操作，而不是针对目标对象进行操作</li>
<li>没有设置任何拦截时，等同于直接通向原对象</li>
<li>属性被定义为不可读写&#x2F;扩展&#x2F;配置&#x2F;枚举时，使用拦截方法会报错</li>
<li>代理下的目标对象，内部 this 指向 Proxy 代理</li>
</ul>
</blockquote>
<h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><ul>
<li>定义：保持 Object 方法的默认行为</li>
<li>方法<ul>
<li>get()：返回对象属性</li>
<li>set()：设置对象属性，返回布尔</li>
<li>has()：检查对象属性，返回布尔</li>
<li>deleteProperty()：删除对象属性，返回布尔</li>
<li>defineProperty()：定义对象属性，返回布尔</li>
<li>ownKeys()：遍历对象属性，返回数组(Object.getOwnPropertyNames()+Object.getOwnPropertySymbols())</li>
<li>getOwnPropertyDescriptor()：返回对象属性描述，返回对象</li>
<li>getPrototypeOf()：返回对象原型，返回对象</li>
<li>setPrototypeOf()：设置对象原型，返回布尔</li>
<li>isExtensible()：返回对象是否可扩展，返回布尔</li>
<li>preventExtensions()：设置对象不可扩展，返回布尔</li>
<li>apply()：绑定 this 后执行指定函数</li>
<li>construct()：调用构造函数创建实例</li>
</ul>
</li>
</ul>
<blockquote>
<p>设计目的</p>
<ul>
<li>将 Object 属于语言内部的方法放到 Reflect 上</li>
<li>将某些 Object 方法报错情况改成返回 false</li>
<li>让 Object 操作变成函数行为</li>
<li>Proxy 与 Reflect 相辅相成</li>
</ul>
</blockquote>
<blockquote>
<p><strong>重难点</strong></p>
<ul>
<li>Proxy 方法和 Reflect 方法一一对应</li>
<li>Proxy 和 Reflect 联合使用，前者负责拦截赋值操作，后者负责完成赋值操作</li>
</ul>
</blockquote>
<blockquote>
<p><strong>数据绑定：观察者模式</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const observerQueue = new Set();</span><br><span class="line">const observe = fn =&gt; observerQueue.add(fn);</span><br><span class="line">const observable = obj =&gt; new Proxy(obj, &#123;</span><br><span class="line">    set(tgt, key, val, receiver) &#123;</span><br><span class="line">        const result = Reflect.set(tgt, key, val, receiver);</span><br><span class="line">        observerQueue.forEach(v =&gt; v());</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const person = observable(&#123; age: 25, name: &quot;Yajun&quot; &#125;);</span><br><span class="line">const print = () =&gt; console.log(`$&#123;person.name&#125; is $&#123;person.age&#125; years old`);</span><br><span class="line">observe(print);</span><br><span class="line">person.name = &quot;Joway&quot;;</span><br></pre></td></tr></table></figure>

<h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><ul>
<li>定义：对一类具有共同特征的事物的抽象(构造函数语法糖)</li>
<li>原理：类本身指向构造函数，所有方法定义在 prototype 上，可看作构造函数的另一种写法(Class &#x3D;&#x3D;&#x3D; Class.prototype.constructor)</li>
<li>方法和关键字<ul>
<li>constructor()：构造函数，new 命令生成实例时自动调用</li>
<li>extends：继承父类</li>
<li>super：新建父类的 this</li>
<li>static：定义静态属性方法</li>
<li>get：取值函数，拦截属性的取值行为</li>
<li>set：存值函数，拦截属性的存值行为</li>
</ul>
</li>
<li>属性<ul>
<li>__proto__：构造函数的继承(总是指向父类)</li>
<li>__proto__.__proto__：子类的原型的原型，即父类的原型(总是指向父类的__proto__)</li>
<li>prototype.__proto__：属性方法的继承(总是指向父类的 prototype)</li>
</ul>
</li>
<li>静态属性：定义类完成后赋值属性，该属性不会被实例继承，只能通过类来调用</li>
<li>静态方法：使用 static 定义方法，该方法不会被实例继承，只能通过类来调用(方法中的 this 指向类，而不是实例)</li>
<li>继承<ul>
<li>实质<ul>
<li>ES5 实质：先创造子类实例的 this，再将父类的属性方法添加到 this 上(Parent.apply(this))</li>
<li>ES6 实质：先将父类实例的属性方法加到 this 上(调用 super())，再用子类构造函数修改 this</li>
</ul>
</li>
<li>super<ul>
<li>作为函数调用：只能在构造函数中调用 super()，内部 this 指向继承的当前子类(super()调用后才可在构造函数中使用 this)</li>
<li>作为对象调用：在普通方法中指向父类的原型对象，在静态方法中指向父类</li>
</ul>
</li>
<li>显示定义：使用 constructor() { super(); }定义继承父类，没有书写则显示定义</li>
<li>子类继承父类：子类使用父类的属性方法时，必须在构造函数中调用 super()，否则得不到父类的 this<ul>
<li>父类静态属性方法可被子类继承</li>
<li>子类继承父类后，可从 super 上调用父类静态属性方法</li>
</ul>
</li>
</ul>
</li>
<li>实例：类相当于实例的原型，所有在类中定义的属性方法都会被实例继承<ul>
<li>显式指定属性方法：使用 this 指定到自身上(使用 Class.hasOwnProperty()可检测到)</li>
<li>隐式指定属性方法：直接声明定义在对象原型上(使用 Class.<strong>proto</strong>.hasOwnProperty()可检测到)</li>
</ul>
</li>
<li>表达式<ul>
<li>类表达式：const Class &#x3D; class {}</li>
<li>name 属性：返回紧跟 class 后的类名</li>
<li>属性表达式：[prop]</li>
<li>Generator 方法：* mothod() {}</li>
<li>Async 方法：async mothod() {}</li>
</ul>
</li>
<li>this 指向：解构实例属性或方法时会报错<ul>
<li>绑定 this：this.mothod &#x3D; this.mothod.bind(this)</li>
<li>箭头函数：this.mothod &#x3D; () &#x3D;&gt; this.mothod()</li>
</ul>
</li>
<li>属性定义位置<ul>
<li>定义在构造函数中并使用 this 指向</li>
<li>定义在类最顶层</li>
</ul>
</li>
<li>new.target：确定构造函数是如何调用</li>
</ul>
<blockquote>
<p>原生构造函数</p>
<ul>
<li>String()</li>
<li>Number()</li>
<li>Boolean()</li>
<li>Object()</li>
<li>Function()</li>
<li>Date()</li>
<li>RegExp()</li>
<li>Error()</li>
</ul>
</blockquote>
<blockquote>
<p>重难点</p>
<ul>
<li>在实例上调用方法，实质是调用原型上的方法</li>
<li>Object.assign()可方便地一次向类添加多个方法(Object.assign(Class.prototype, { … }))</li>
<li>类内部所有定义的方法是不可枚举的(non-enumerable)</li>
<li>构造函数默认返回实例对象(this)，可指定返回另一个对象</li>
<li>取值函数和存值函数设置在属性的 Descriptor 对象上</li>
<li>类不存在变量提升</li>
<li>利用 new.target &#x3D;&#x3D;&#x3D; Class 写出不能独立使用必须继承后才能使用的类</li>
<li>子类继承父类后，this 指向子类实例，通过 super 对某个属性赋值，赋值的属性会变成子类实例的属性</li>
<li>使用 super 时，必须显式指定是作为函数还是作为对象使用</li>
<li>extends 不仅可继承类还可继承原生的构造函数</li>
</ul>
</blockquote>
<blockquote>
<p><strong>私有属性方法</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const name = Symbol(&quot;name&quot;);</span><br><span class="line">const print = Symbol(&quot;print&quot;);</span><br><span class="line">class Person &#123;</span><br><span class="line">    constructor(age) &#123;</span><br><span class="line">        this[name] = &quot;Bruce&quot;;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    [print]() &#123;</span><br><span class="line">        console.log(`$&#123;this[name]&#125; is $&#123;this.age&#125; years old`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>继续混合类</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function CopyProperties(target, source) &#123;</span><br><span class="line">    for (const key of Reflect.ownKeys(source)) &#123;</span><br><span class="line">        if (key !== &quot;constructor&quot; &amp;&amp; key !== &quot;prototype&quot; &amp;&amp; key !== &quot;name&quot;) &#123;</span><br><span class="line">            const desc = Object.getOwnPropertyDescriptor(source, key);</span><br><span class="line">            Object.defineProperty(target, key, desc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function MixClass(...mixins) &#123;</span><br><span class="line">    class Mix &#123;</span><br><span class="line">        constructor() &#123;</span><br><span class="line">            for (const mixin of mixins) &#123;</span><br><span class="line">                CopyProperties(this, new mixin());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (const mixin of mixins) &#123;</span><br><span class="line">        CopyProperties(Mix, mixin);</span><br><span class="line">        CopyProperties(Mix.prototype, mixin.prototype);</span><br><span class="line">    &#125;</span><br><span class="line">    return Mix;</span><br><span class="line">&#125;</span><br><span class="line">class Student extends MixClass(Person, Kid) &#123;&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tongxinyou.github.io/2022/10/28/js%E5%9F%BA%E7%A1%80-es6%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/tongju.github.io/images/avatar.gif">
      <meta itemprop="name" content="墨白">
      <meta itemprop="description" content="个人技术成长之路">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="墨白的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/tongju.github.io/2022/10/28/js%E5%9F%BA%E7%A1%80-es6%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">ES6相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tongju.github.io/categories/js%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">js基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="es6-相关特性-（一）"><a href="#es6-相关特性-（一）" class="headerlink" title="es6 相关特性 （一）"></a>es6 相关特性 （一）</h1><blockquote>
<p>ES6 既是一个历史名词也是一个泛指，含义是 5.1 版本以后的 JavaScript 下一代标准，目前涵盖了 ES2015、ES2016、ES2017、ES2018、ES2019、ES2020。</p>
</blockquote>
<p>ES6 更新的内容主要分为以下几点</p>
<p>表达式：声明、解构赋值<br>内置对象：字符串扩展、数值扩展、对象扩展、数组扩展、函数扩展、正则扩展、Symbol、Set、Map、Proxy、Reflect<br>语句与运算：Class、Module、Iterator<br>异步编程：Promise、Generator、Async</p>
<h2 id="ES2015"><a href="#ES2015" class="headerlink" title="ES2015"></a>ES2015</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><blockquote>
<p>const 命令：声明常量<br>let 命令：声明变量</p>
</blockquote>
<h5 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h5><blockquote>
<p><strong>作用域:</strong><br>全局作用域<br>函数作用域：function(){}<br>块级作用域：{}</p>
</blockquote>
<blockquote>
<p><strong>作用范围:</strong><br>var 命令在全局代码中执行<br>const 命令和 let 命令只能在代码块中执行</p>
</blockquote>
<blockquote>
<p><strong>赋值使用:</strong><br>const 命令声明常量后必须立马赋值<br>let 命令声明变量后可立马赋值或使用时赋值</p>
</blockquote>
<blockquote>
<p><strong>声明方法:</strong> var、const、let、function、class、import</p>
</blockquote>
<h5 id="重难点"><a href="#重难点" class="headerlink" title="重难点"></a>重难点</h5><ul>
<li>不允许重复声明</li>
<li>未定义就使用会报错：const 命令和 let 命令不存在变量提升</li>
<li>暂时性死区：在代码块内使用 const 命令和 let 命令声明变量之前，该变量都不可用</li>
</ul>
<h3 id="结构赋值"><a href="#结构赋值" class="headerlink" title="结构赋值"></a>结构赋值</h3><ul>
<li>字符串解构：const [a, b, c, d, e] &#x3D; “hello”</li>
<li>数值解构：const { toString: s } &#x3D; 123</li>
<li>布尔解构：const { toString: b } &#x3D; true</li>
<li>对象解构：<ul>
<li>形式：const { x, y } &#x3D; { x: 1, y: 2 }</li>
<li>默认：const { x, y &#x3D; 2 } &#x3D; { x: 1 }</li>
<li>改名：const { x, y: z } &#x3D; { x: 1, y: 2 }</li>
</ul>
</li>
<li>数组解构:<ul>
<li>规则：数据结构具有 Iterator 接口可采用数组形式的解构赋值</li>
<li>形式：const [x, y] &#x3D; [1, 2]</li>
<li>默认：const [x, y &#x3D; 2] &#x3D; [1]</li>
</ul>
</li>
<li>函数参数解构<ul>
<li>数组解构：function Func([x &#x3D; 0, y &#x3D; 1]) {}</li>
<li>对象解构：function Func({ x &#x3D; 0, y &#x3D; 1 } &#x3D; {}) {}</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>应用场景</strong></p>
<ul>
<li>交换变量值：[x, y] &#x3D; [y, x]</li>
<li>返回函数多个值：const [x, y, z] &#x3D; Func()</li>
<li>定义函数参数：Func([1, 2])</li>
<li>提取 JSON 数据：const { name, version } &#x3D; packageJson</li>
<li>定义函数参数默认值：function Func({ x &#x3D; 1, y &#x3D; 2 } &#x3D; {}) {}</li>
<li>遍历 Map 结构：for (let [k, v] of Map) {}</li>
<li>输入模块指定属性和方法：const { readFile, writeFile } &#x3D; require(“fs”)</li>
</ul>
</blockquote>
<blockquote>
<p><strong>重难点</strong></p>
<ul>
<li>匹配模式：只要等号两边的模式相同，左边的变量就会被赋予对应的值</li>
<li>解构赋值规则：只要等号右边的值不是对象或数组，就先将其转为对象</li>
<li>解构默认值生效条件：属性值严格等于 undefined</li>
<li>解构遵循匹配模式</li>
<li>解构不成功时变量的值等于 undefined</li>
<li>undefined 和 null 无法转为对象，因此无法进行解构</li>
</ul>
</blockquote>
<h3 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h3><ul>
<li>Unicode 表示法：大括号包含表示 Unicode 字符(\u{0xXX}或\u{0XXX})</li>
<li>字符串遍历：可通过 for-of 遍历字符串</li>
<li>字符串模板：可单行可多行可插入变量的增强版字符串</li>
<li>标签模板：函数参数的特殊调用</li>
<li>String.raw()：返回把字符串所有变量替换且对斜杠进行转义的结果</li>
<li>String.fromCodePoint()：返回码点对应字符</li>
<li>codePointAt()：返回字符对应码点(String.fromCodePoint()的逆操作)</li>
<li>normalize()：把字符的不同表示方法统一为同样形式，返回新字符串(Unicode 正规化)</li>
<li>repeat()：把字符串重复 n 次，返回新字符串</li>
<li>matchAll()：返回正则表达式在字符串的所有匹配</li>
<li>includes()：是否存在指定字符串</li>
<li>startsWith()：是否存在字符串头部指定字符串</li>
<li>endsWith()：是否存在字符串尾部指定字符串</li>
</ul>
<blockquote>
<p><strong>重难点:</strong><br>以上扩展方法均可作用于由 4 个字节储存的 Unicode 字符上</p>
</blockquote>
<h3 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展"></a>数值扩展</h3><ul>
<li>二进制表示法：0b 或 0B 开头表示二进制(0bXX 或 0BXX)</li>
<li>八进制表示法：0o 或 0O 开头表示二进制(0oXX 或 0OXX)</li>
<li>Number.EPSILON：数值最小精度</li>
<li>Number.MIN_SAFE_INTEGER：最小安全数值(-2^53)</li>
<li>Number.MAX_SAFE_INTEGER：最大安全数值(2^53)</li>
<li>Number.parseInt()：返回转换值的整数部分</li>
<li>Number.parseFloat()：返回转换值的浮点数部分</li>
<li>Number.isFinite()：是否为有限数值</li>
<li>Number.isNaN()：是否为 NaN</li>
<li>Number.isInteger()：是否为整数</li>
<li>Number.isSafeInteger()：是否在数值安全范围内</li>
<li>Math.trunc()：返回数值整数部分</li>
<li>Math.sign()：返回数值类型(正数 1、负数-1、零 0)</li>
<li>Math.cbrt()：返回数值立方根</li>
<li>Math.clz32()：返回数值的 32 位无符号整数形式</li>
<li>Math.imul()：返回两个数值相乘</li>
<li>Math.fround()：返回数值的 32 位单精度浮点数形式</li>
<li>Math.hypot()：返回所有数值平方和的平方根</li>
<li>Math.expm1()：返回 e^n - 1</li>
<li>Math.log1p()：返回 1 + n 的自然对数(Math.log(1 + n))</li>
<li>Math.log10()：返回以 10 为底的 n 的对数</li>
<li>Math.log2()：返回以 2 为底的 n 的对数</li>
<li>Math.sinh()：返回 n 的双曲正弦</li>
<li>Math.cosh()：返回 n 的双曲余弦</li>
<li>Math.tanh()：返回 n 的双曲正切</li>
<li>Math.asinh()：返回 n 的反双曲正弦</li>
<li>Math.acosh()：返回 n 的反双曲余弦</li>
<li>Math.atanh()：返回 n 的反双曲正切</li>
</ul>
<h3 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h3><ul>
<li>简洁表示法：直接写入变量和函数作为对象的属性和方法({ prop, method() {} })</li>
<li>属性名表达式：字面量定义对象时使用[]定义键([prop]，不能与上同时使用)</li>
<li>方法的 name 属性：返回方法函数名<ul>
<li>取值函数(getter)和存值函数(setter)：get&#x2F;set 函数名(属性的描述对象在 get 和 set 上)</li>
<li>bind 返回的函数：bound 函数名</li>
<li>Function 构造函数返回的函数实例：anonymous</li>
</ul>
</li>
<li>属性的可枚举性和遍历：描述对象的 enumerable</li>
<li>super 关键字：指向当前对象的原型对象(只能用在对象的简写方法中 method() {})</li>
<li>Object.is()：对比两值是否相等</li>
<li>Object.assign()：合并对象(浅拷贝)，返回原对象</li>
<li>Object.getPrototypeOf()：返回对象的原型对象</li>
<li>Object.setPrototypeOf()：设置对象的原型对象</li>
<li>__ proto __：返回或设置对象的原型对象</li>
</ul>
<blockquote>
<p>属性遍历<br><strong>描述:</strong> 自身、可继承、可枚举、非枚举、Symbol<br><strong>遍历:</strong></p>
<ul>
<li>for-in：遍历对象自身可继承可枚举属性</li>
<li>Object.keys()：返回对象自身可枚举属性键组成的数组</li>
<li>Object.getOwnPropertyNames()：返回对象自身非 Symbol 属性键组成的数组</li>
<li>Object.getOwnPropertySymbols()：返回对象自身 Symbol 属性键组成的数组</li>
<li>Reflect.ownKeys()：返回对象自身全部属性键组成的数组</li>
</ul>
<p><strong>规则:</strong></p>
<ul>
<li>首先遍历所有数值键，按照数值升序排列</li>
<li>其次遍历所有字符串键，按照加入时间升序排列</li>
<li>最后遍历所有 Symbol 键，按照加入时间升序排列</li>
</ul>
</blockquote>
<h3 id="数组扩展"><a href="#数组扩展" class="headerlink" title="数组扩展"></a>数组扩展</h3><ul>
<li>扩展运算符(…)：转换数组为用逗号分隔的参数序列([…arr]，相当于 rest&#x2F;spread 参数的逆运算)</li>
<li>Array.from()：转换具有 Iterator 接口的数据结构为真正数组，返回新数组<ul>
<li>类数组对象：包含 length 的对象、Arguments 对象、NodeList 对象</li>
<li>可遍历对象：String、Set 结构、Map 结构、Generator 函数</li>
</ul>
</li>
<li>Array.of()：转换一组值为真正数组，返回新数组</li>
<li>copyWithin()：把指定位置的成员复制到其他位置，返回原数组</li>
<li>find()：返回第一个符合条件的成员</li>
<li>findIndex()：返回第一个符合条件的成员索引值</li>
<li>fill()：根据指定值填充整个数组，返回原数组</li>
<li>keys()：返回以索引值为遍历器的对象</li>
<li>values()：返回以属性值为遍历器的对象</li>
<li>entries()：返回以索引值和属性值为遍历器的对象</li>
<li>数组空位：ES6 明确将数组空位转为 undefined(空位处理规不一，建议避免出现)</li>
</ul>
<blockquote>
<p><strong>扩展应用</strong></p>
<ul>
<li>克隆数组：const arr &#x3D; […arr1]</li>
<li>合并数组：const arr &#x3D; […arr1, …arr2]</li>
<li>拼接数组：arr.push(…arr1)</li>
<li>代替 apply：Math.max.apply(null, [x, y]) &#x3D;&gt; Math.max(…[x, y])</li>
<li>转换字符串为数组：[…”hello”]</li>
<li>转换类数组对象为数组：[…Arguments, …NodeList]</li>
<li>转换可遍历对象为数组：[…String, …Set, …Map, …Generator]</li>
<li>与数组解构赋值结合：const [x, …rest&#x2F;spread] &#x3D; [1, 2, 3]</li>
<li>计算 Unicode 字符长度：Array.from(“hello”).length &#x3D;&gt; […”hello”].length</li>
</ul>
</blockquote>
<blockquote>
<p><strong>重难点</strong><br>使用 keys()、values()、entries()返回的遍历器对象，可用 for-of 自动遍历或 next()手动遍历</p>
</blockquote>
<h3 id="函数扩展"><a href="#函数扩展" class="headerlink" title="函数扩展"></a>函数扩展</h3><ul>
<li><strong>参数默认值</strong>：为函数参数指定默认值<ul>
<li>形式：function Func(x &#x3D; 1, y &#x3D; 2) {}</li>
<li>参数赋值：惰性求值(函数调用后才求值)</li>
<li>参数位置：尾参数</li>
<li>参数作用域：函数作用域</li>
<li>声明方式：默认声明，不能用 const 或 let 再次声明</li>
<li>length：返回没有指定默认值的参数个数</li>
<li>与解构赋值默认值结合：function Func({ x &#x3D; 1, y &#x3D; 2 } &#x3D; {}) {}</li>
<li>应用<ul>
<li>指定某个参数不得省略，省略即抛出错误：function Func(x &#x3D; throwMissing()) {}</li>
<li>将参数默认值设为 undefined，表明此参数可省略：Func(undefined, 1)</li>
</ul>
</li>
</ul>
</li>
<li>**rest&#x2F;spread 参数(…)**：返回函数多余参数<ul>
<li>形式：以数组的形式存在，之后不能再有其他参数</li>
<li>作用：代替 Arguments 对象</li>
<li>length：返回没有指定默认值的参数个数但不包括 rest&#x2F;spread 参数</li>
</ul>
</li>
<li><strong>严格模式：</strong> 在严格条件下运行 JS<ul>
<li>应用：只要函数参数使用默认值、解构赋值、扩展运算符，那么函数内部就不能显式设定为严格模式</li>
</ul>
</li>
<li><strong>name 属性：</strong> 返回函数的函数名<ul>
<li>将匿名函数赋值给变量：空字符串(ES5)、变量名(ES6)</li>
<li>将具名函数赋值给变量：函数名(ES5 和 ES6)</li>
<li>bind 返回的函数：bound 函数名(ES5 和 ES6)</li>
<li>Function 构造函数返回的函数实例：anonymous(ES5 和 ES6)</li>
</ul>
</li>
<li>**箭头函数(&#x3D;&gt;)**：函数简写<ul>
<li>无参数：() &#x3D;&gt; {}</li>
<li>单个参数：x &#x3D;&gt; {}</li>
<li>多个参数：(x, y) &#x3D;&gt; {}</li>
<li>解构参数：({x, y}) &#x3D;&gt; {}</li>
<li>嵌套使用：部署管道机制</li>
<li>this 指向固定化<ul>
<li>并非因为内部有绑定 this 的机制，而是根本没有自己的 this，导致内部的 this 就是外层代码块的 this</li>
<li>因为没有 this，因此不能用作构造函数</li>
</ul>
</li>
</ul>
</li>
<li><strong>尾调用优化：</strong> 只保留内层函数的调用帧<ul>
<li>尾调用<ul>
<li>定义：某个函数的最后一步是调用另一个函数</li>
<li>形式：function f(x) { return g(x); }</li>
</ul>
</li>
<li>尾递归<ul>
<li>定义：函数尾调用自身</li>
<li>作用：只要使用尾递归就不会发生栈溢出，相对节省内存</li>
<li>实现：把所有用到的内部变量改写成函数的参数并使用参数默认值</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>箭头函数误区</p>
<ul>
<li>函数体内的 this 是定义时所在的对象而不是使用时所在的对象</li>
<li>可让 this 指向固定化，这种特性很有利于封装回调函数</li>
<li>不可当作构造函数，因此箭头函数不可使用 new 命令</li>
<li>不可使用 yield 命令，因此箭头函数不能用作 Generator 函数</li>
<li>不可使用 Arguments 对象，此对象在函数体内不存在(可用 rest&#x2F;spread 参数代替)</li>
<li>返回对象时必须在对象外面加上括号</li>
</ul>
</blockquote>
<h3 id="正则扩展"><a href="#正则扩展" class="headerlink" title="正则扩展"></a>正则扩展</h3><ul>
<li><strong>变更 RegExp 构造函数入参</strong>：允许首参数为正则对象，尾参数为正则修饰符(返回的正则表达式会忽略原正则表达式的修饰符)</li>
<li><strong>正则方法调用变更</strong>：字符串对象的 match()、replace()、search()、split()内部调用转为调用 RegExp 实例对应的 RegExp.prototype[Symbol.方法]</li>
<li><strong>u 修饰符</strong>：Unicode 模式修饰符，正确处理大于\uFFFF 的 Unicode 字符<ul>
<li>点字符(.)</li>
<li>Unicode 表示法</li>
<li>量词</li>
<li>预定义模式</li>
<li>i 修饰符</li>
<li>转义</li>
</ul>
</li>
<li>y 修饰符：粘连修饰符，确保匹配必须从剩余的第一个位置开始全局匹配(与 g 修饰符作用类似)</li>
<li>unicode：是否设置 u 修饰符</li>
<li>sticky：是否设置 y 修饰符</li>
<li>flags：返回正则表达式的修饰符</li>
</ul>
<blockquote>
<p>重难点</p>
<ul>
<li>y 修饰符隐含头部匹配标志^</li>
<li>单单一个 y 修饰符对 match()只能返回第一个匹配，必须与 g 修饰符联用才能返回所有匹配</li>
</ul>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/tongju.github.io/page/2/">2</a><a class="extend next" rel="next" href="/tongju.github.io/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">墨白</p>
  <div class="site-description" itemprop="description">个人技术成长之路</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/tongju.github.io/archives">
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/tongju.github.io/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">墨白</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script color='' opacity='' zIndex='' count='' src="/tongju.github.io/lib/canvas-nest/canvas-nest-nomobile.min.js"></script>
  <script src="/tongju.github.io/lib/anime.min.js"></script>
  <script src="/tongju.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/tongju.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/tongju.github.io/js/utils.js"></script>

<script src="/tongju.github.io/js/motion.js"></script>


<script src="/tongju.github.io/js/schemes/pisces.js"></script>


<script src="/tongju.github.io/js/next-boot.js"></script>




  















  

  


</body>
</html>
