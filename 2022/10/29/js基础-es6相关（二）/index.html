<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/tongju.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/tongju.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/tongju.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/tongju.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/tongju.github.io/css/main.css">


<link rel="stylesheet" href="/tongju.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"tongxinyou.github.io","root":"/tongju.github.io/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="es6 相关特性 （二）ES2015Symbol 定义：独一无二的值  声明：const set &#x3D; Symbol(str)  入参：字符串(可选)  方法  Symbol()：创建以参数作为描述的 Symbol 值(不登记在全局环境) Symbol.for()：创建以参数作为描述的 Symbol 值，如存在此参数则返回原有的 Symbol 值(先搜索后创建，登记在全局环境) Symbo">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6相关（二）">
<meta property="og:url" content="https://tongxinyou.github.io/2022/10/29/js%E5%9F%BA%E7%A1%80-es6%E7%9B%B8%E5%85%B3%EF%BC%88%E4%BA%8C%EF%BC%89/index.html">
<meta property="og:site_name" content="墨白的博客">
<meta property="og:description" content="es6 相关特性 （二）ES2015Symbol 定义：独一无二的值  声明：const set &#x3D; Symbol(str)  入参：字符串(可选)  方法  Symbol()：创建以参数作为描述的 Symbol 值(不登记在全局环境) Symbol.for()：创建以参数作为描述的 Symbol 值，如存在此参数则返回原有的 Symbol 值(先搜索后创建，登记在全局环境) Symbo">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-10-29T02:58:20.067Z">
<meta property="article:author" content="墨白">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://tongxinyou.github.io/2022/10/29/js%E5%9F%BA%E7%A1%80-es6%E7%9B%B8%E5%85%B3%EF%BC%88%E4%BA%8C%EF%BC%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>ES6相关（二） | 墨白的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/tongju.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">墨白的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">个人技术成长之路</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/tongju.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/tongju.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tongxinyou.github.io/2022/10/29/js%E5%9F%BA%E7%A1%80-es6%E7%9B%B8%E5%85%B3%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/tongju.github.io/images/avatar.gif">
      <meta itemprop="name" content="墨白">
      <meta itemprop="description" content="个人技术成长之路">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="墨白的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ES6相关（二）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tongju.github.io/categories/js%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">js基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="es6-相关特性-（二）"><a href="#es6-相关特性-（二）" class="headerlink" title="es6 相关特性 （二）"></a>es6 相关特性 （二）</h1><h2 id="ES2015"><a href="#ES2015" class="headerlink" title="ES2015"></a>ES2015</h2><h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><ul>
<li><p>定义：独一无二的值</p>
</li>
<li><p>声明：const set &#x3D; Symbol(str)</p>
</li>
<li><p>入参：字符串(可选)</p>
</li>
<li><p>方法</p>
<ul>
<li>Symbol()：创建以参数作为描述的 Symbol 值(不登记在全局环境)</li>
<li>Symbol.for()：创建以参数作为描述的 Symbol 值，如存在此参数则返回原有的 Symbol 值(先搜索后创建，登记在全局环境)</li>
<li>Symbol.keyFor()：返回已登记的 Symbol 值的描述(只能返回 Symbol.for()的 key)</li>
<li>Object.getOwnPropertySymbols()：返回对象中所有用作属性名的 Symbol 值的数组</li>
</ul>
</li>
<li><p>内置</p>
<ul>
<li>Symbol.hasInstance：指向一个内部方法，当其他对象使用 instanceof 运算符判断是否为此对象的实例时会调用此方法</li>
<li>Symbol.isConcatSpreadable：指向一个布尔，定义对象用于 Array.prototype.concat()时是否可展开</li>
<li>Symbol.species：指向一个构造函数，当实例对象使用自身构造函数时会调用指定的构造函数</li>
<li>Symbol.match：指向一个函数，当实例对象被 String.prototype.match()调用时会重新定义 match()的行为</li>
<li>Symbol.replace：指向一个函数，当实例对象被 String.prototype.replace()调用时会重新定义 replace()的行为</li>
<li>Symbol.search：指向一个函数，当实例对象被 String.prototype.search()调用时会重新定义 search()的行为</li>
<li>Symbol.split：指向一个函数，当实例对象被 String.prototype.split()调用时会重新定义 split()的行为</li>
<li>Symbol.iterator：指向一个默认遍历器方法，当实例对象执行 for-of 时会调用指定的默认遍历器</li>
<li>Symbol.toPrimitive：指向一个函数，当实例对象被转为原始类型的值时会返回此对象对应的原始类型值</li>
<li>Symbol.toStringTag：指向一个函数，当实例对象被 Object.prototype.toString()调用时其返回值会出现在 toString()返回的字符串之中表示对象的类型</li>
<li>Symbol.unscopables：指向一个对象，指定使用 with 时哪些属性会被 with 环境排除</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>数据类型:</strong></p>
<ul>
<li>Undefined</li>
<li>Null</li>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>Object(包含 Array、Function、Date、RegExp、Error)</li>
<li>Symbol</li>
</ul>
</blockquote>
<blockquote>
<p><strong>应用场景</strong></p>
<ul>
<li>唯一化对象属性名：属性名属于 Symbol 类型，就都是独一无二的，可保证不会与其他属性名产生冲突</li>
<li>消除魔术字符串：在代码中多次出现且与代码形成强耦合的某一个具体的字符串或数值</li>
<li>遍历属性名：无法通过 for-in、for-of、Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回，只能通过 Object.getOwnPropertySymbols 返回</li>
<li>启用模块的 Singleton 模式：调用一个类在任何时候返回同一个实例(window 和 global)，使用 Symbol.for()来模拟全局的 Singleton 模式</li>
</ul>
</blockquote>
<blockquote>
<p><strong>重难点</strong></p>
<ul>
<li>Symbol()生成一个原始类型的值不是对象，因此 Symbol()前不能使用 new 命令</li>
<li>Symbol()参数表示对当前 Symbol 值的描述，相同参数的 Symbol()返回值不相等</li>
<li>Symbol 值不能与其他类型的值进行运算</li>
<li>Symbol 值可通过 String()或 toString()显式转为字符串</li>
<li>Symbol 值作为对象属性名时，此属性是公开属性，但不是私有属性</li>
<li>Symbol 值作为对象属性名时，只能用方括号运算符([])读取，不能用点运算符(.)读取</li>
<li>Symbol 值作为对象属性名时，不会被常规方法遍历得到，可利用此特性为对象定义非私有但又只用于内部的方法</li>
</ul>
</blockquote>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="Set-1"><a href="#Set-1" class="headerlink" title="Set"></a>Set</h4><ul>
<li>定义：类似于数组的数据结构，成员值都是唯一且没有重复的值</li>
<li>声明：const set &#x3D; new Set(arr)</li>
<li>入参：具有 Iterator 接口的数据结构</li>
<li>属性<ul>
<li>constructor：构造函数，返回 Set</li>
<li>size：返回实例成员总数</li>
</ul>
</li>
<li>方法<ul>
<li>add()：添加值，返回实例</li>
<li>delete()：删除值，返回布尔</li>
<li>has()：检查值，返回布尔</li>
<li>clear()：清除所有成员</li>
<li>keys()：返回以属性值为遍历器的对象</li>
<li>values()：返回以属性值为遍历器的对象</li>
<li>entries()：返回以属性值和属性值为遍历器的对象</li>
<li>forEach()：使用回调函数遍历每个成员</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>应用场景</strong></p>
<ul>
<li>去重字符串：[…new Set(str)].join(“”)</li>
<li>去重数组：[…new Set(arr)]或 Array.from(new Set(arr))</li>
<li>集合数组<ul>
<li>声明：const a &#x3D; new Set(arr1)、const b &#x3D; new Set(arr2)</li>
<li>并集：new Set([…a, …b])</li>
<li>交集：new Set([…a].filter(v &#x3D;&gt; b.has(v)))</li>
<li>差集：new Set([…a].filter(v &#x3D;&gt; !b.has(v)))</li>
</ul>
</li>
<li>映射集合<ul>
<li>声明：let set &#x3D; new Set(arr)</li>
<li>映射：set &#x3D; new Set([…set].map(v &#x3D;&gt; v _ 2))或 set &#x3D; new Set(Array.from(set, v &#x3D;&gt; v _ 2))</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p><strong>重难点</strong></p>
<ul>
<li>遍历顺序：插入顺序</li>
<li>没有键只有值，可认为键和值两值相等</li>
<li>添加多个 NaN 时，只会存在一个 NaN</li>
<li>添加相同的对象时，会认为是不同的对象</li>
<li>添加值时不会发生类型转换(5 !&#x3D;&#x3D; “5”)</li>
<li>keys()和 values()的行为完全一致，entries()返回的遍历器同时包括键和值且两值相等</li>
</ul>
</blockquote>
<h4 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h4><ul>
<li>定义：和 Set 结构类似，成员值只能是对象</li>
<li>声明：const set &#x3D; new WeakSet(arr)</li>
<li>入参：具有 Iterator 接口的数据结构</li>
<li>属性<ul>
<li>constructor：构造函数，返回 WeakSet</li>
</ul>
</li>
<li>方法<ul>
<li>add()：添加值，返回实例</li>
<li>delete()：删除值，返回布尔</li>
<li>has()：检查值，返回布尔</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>应用场景</strong></p>
<ul>
<li>储存 DOM 节点：DOM 节点被移除时自动释放此成员，不用担心这些节点从文档移除时会引发内存泄漏</li>
<li>临时存放一组对象或存放跟对象绑定的信息：只要这些对象在外部消失，它在 WeakSet 结构中的引用就会自动消</li>
</ul>
</blockquote>
<blockquote>
<p><strong>重难点</strong></p>
<ul>
<li>成员都是弱引用，垃圾回收机制不考虑 WeakSet 结构对此成员的引用</li>
<li>成员不适合引用，它会随时消失，因此 ES6 规定 WeakSet 结构不可遍历</li>
<li>其他对象不再引用成员时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于 WeakSet 结构中</li>
</ul>
</blockquote>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h4><ul>
<li>定义：类似于对象的数据结构，成员键是任何类型的值</li>
<li>声明：const set &#x3D; new Map(arr)</li>
<li>入参：具有 Iterator 接口且每个成员都是一个双元素数组的数据结构</li>
<li>属性<ul>
<li>constructor：构造函数，返回 Map</li>
<li>size：返回实例成员总数</li>
</ul>
</li>
<li>方法<ul>
<li>get()：返回键值对</li>
<li>set()：添加键值对，返回实例</li>
<li>delete()：删除键值对，返回布尔</li>
<li>has()：检查键值对，返回布尔</li>
<li>clear()：清除所有成员</li>
<li>keys()：返回以键为遍历器的对象</li>
<li>values()：返回以值为遍历器的对象</li>
<li>entries()：返回以键和值为遍历器的对象</li>
<li>forEach()：使用回调函数遍历每个成员</li>
</ul>
</li>
</ul>
<blockquote>
<p>重难点</p>
<ul>
<li>遍历顺序：插入顺序</li>
<li>对同一个键多次赋值，后面的值将覆盖前面的值</li>
<li>对同一个对象的引用，被视为一个键</li>
<li>对同样值的两个实例，被视为两个键</li>
<li>键跟内存地址绑定，只要内存地址不一样就视为两个键</li>
<li>添加多个以 NaN 作为键时，只会存在一个以 NaN 作为键的值</li>
<li>Object 结构提供字符串—值的对应，Map 结构提供值—值的对应</li>
</ul>
</blockquote>
<h4 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h4><ul>
<li>定义：和 Map 结构类似，成员键只能是对象</li>
<li>声明：const set &#x3D; new WeakMap(arr)</li>
<li>入参：具有 Iterator 接口且每个成员都是一个双元素数组的数据结构</li>
<li>属性<ul>
<li>constructor：构造函数，返回 WeakMap</li>
</ul>
</li>
<li>方法<ul>
<li>get()：返回键值对</li>
<li>set()：添加键值对，返回实例</li>
<li>delete()：删除键值对，返回布尔</li>
<li>has()：检查键值对，返回布尔</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>应用场景</strong></p>
<ul>
<li>储存 DOM 节点：DOM 节点被移除时自动释放此成员键，不用担心这些节点从文档移除时会引发内存泄漏</li>
<li>部署私有属性：内部属性是实例的弱引用，删除实例时它们也随之消失，不会造成内存泄漏</li>
</ul>
</blockquote>
<blockquote>
<p>重难点</p>
<ul>
<li>成员键都是弱引用，垃圾回收机制不考虑 WeakMap 结构对此成员键的引用</li>
<li>成员键不适合引用，它会随时消失，因此 ES6 规定 WeakMap 结构不可遍历</li>
<li>其他对象不再引用成员键时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于 WeakMap 结构中</li>
<li>一旦不再需要，成员会自动消失，不用手动删除引用</li>
<li>弱引用的只是键而不是值，值依然是正常引用</li>
<li>即使在外部消除了成员键的引用，内部的成员值依然存在</li>
</ul>
</blockquote>
<h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><ul>
<li>定义：修改某些操作的默认行为</li>
<li>声明：const proxy &#x3D; new Proxy(target, handler)</li>
<li>入参<ul>
<li>target：拦截的目标对象</li>
<li>handler：定制拦截行为</li>
</ul>
</li>
<li>方法<ul>
<li>Proxy.revocable()：返回可取消的 Proxy 实例(返回{ proxy, revoke }，通过 revoke()取消代理)</li>
</ul>
</li>
<li>拦截方式<ul>
<li>get()：拦截对象属性读取</li>
<li>set()：拦截对象属性设置，返回布尔</li>
<li>has()：拦截对象属性检查 k in obj，返回布尔</li>
<li>deleteProperty()：拦截对象属性删除 delete obj[k]，返回布尔</li>
<li>defineProperty()：拦截对象属性定义 Object.defineProperty()、Object.defineProperties()，返回布尔</li>
<li>ownKeys()：拦截对象属性遍历 for-in、Object.keys()、Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()，返回数组</li>
<li>getOwnPropertyDescriptor()：拦截对象属性描述读取 Object.getOwnPropertyDescriptor()，返回对象</li>
<li>getPrototypeOf()：拦截对象原型读取 instanceof、Object.getPrototypeOf()、Object.prototype.<strong>proto</strong>、Object.prototype.isPrototypeOf()、Reflect.getPrototypeOf()，返回对象</li>
<li>setPrototypeOf()：拦截对象原型设置 Object.setPrototypeOf()，返回布尔</li>
<li>isExtensible()：拦截对象是否可扩展读取 Object.isExtensible()，返回布尔</li>
<li>preventExtensions()：拦截对象不可扩展设置 Object.preventExtensions()，返回布尔</li>
<li>apply()：拦截 Proxy 实例作为函数调用 proxy()、proxy.apply()、proxy.call()</li>
<li>construct()：拦截 Proxy 实例作为构造函数调用 new proxy()</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>应用场景</strong></p>
<ul>
<li>Proxy.revocable()：不允许直接访问对象，必须通过代理访问，一旦访问结束就收回代理权不允许再次访问</li>
<li>get()：读取未知属性报错、读取数组负数索引的值、封装链式操作、生成 DOM 嵌套节点</li>
<li>set()：数据绑定(Vue 数据绑定实现原理)、确保属性值设置符合要求、防止内部属性被外部读写</li>
<li>has()：隐藏内部属性不被发现、排除不符合属性条件的对象</li>
<li>deleteProperty()：保护内部属性不被删除</li>
<li>defineProperty()：阻止属性被外部定义</li>
<li>ownKeys()：保护内部属性不被遍历</li>
</ul>
</blockquote>
<blockquote>
<p>重难点</p>
<ul>
<li>要使 Proxy 起作用，必须针对实例进行操作，而不是针对目标对象进行操作</li>
<li>没有设置任何拦截时，等同于直接通向原对象</li>
<li>属性被定义为不可读写&#x2F;扩展&#x2F;配置&#x2F;枚举时，使用拦截方法会报错</li>
<li>代理下的目标对象，内部 this 指向 Proxy 代理</li>
</ul>
</blockquote>
<h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><ul>
<li>定义：保持 Object 方法的默认行为</li>
<li>方法<ul>
<li>get()：返回对象属性</li>
<li>set()：设置对象属性，返回布尔</li>
<li>has()：检查对象属性，返回布尔</li>
<li>deleteProperty()：删除对象属性，返回布尔</li>
<li>defineProperty()：定义对象属性，返回布尔</li>
<li>ownKeys()：遍历对象属性，返回数组(Object.getOwnPropertyNames()+Object.getOwnPropertySymbols())</li>
<li>getOwnPropertyDescriptor()：返回对象属性描述，返回对象</li>
<li>getPrototypeOf()：返回对象原型，返回对象</li>
<li>setPrototypeOf()：设置对象原型，返回布尔</li>
<li>isExtensible()：返回对象是否可扩展，返回布尔</li>
<li>preventExtensions()：设置对象不可扩展，返回布尔</li>
<li>apply()：绑定 this 后执行指定函数</li>
<li>construct()：调用构造函数创建实例</li>
</ul>
</li>
</ul>
<blockquote>
<p>设计目的</p>
<ul>
<li>将 Object 属于语言内部的方法放到 Reflect 上</li>
<li>将某些 Object 方法报错情况改成返回 false</li>
<li>让 Object 操作变成函数行为</li>
<li>Proxy 与 Reflect 相辅相成</li>
</ul>
</blockquote>
<blockquote>
<p><strong>重难点</strong></p>
<ul>
<li>Proxy 方法和 Reflect 方法一一对应</li>
<li>Proxy 和 Reflect 联合使用，前者负责拦截赋值操作，后者负责完成赋值操作</li>
</ul>
</blockquote>
<blockquote>
<p><strong>数据绑定：观察者模式</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const observerQueue = new Set();</span><br><span class="line">const observe = fn =&gt; observerQueue.add(fn);</span><br><span class="line">const observable = obj =&gt; new Proxy(obj, &#123;</span><br><span class="line">    set(tgt, key, val, receiver) &#123;</span><br><span class="line">        const result = Reflect.set(tgt, key, val, receiver);</span><br><span class="line">        observerQueue.forEach(v =&gt; v());</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const person = observable(&#123; age: 25, name: &quot;Yajun&quot; &#125;);</span><br><span class="line">const print = () =&gt; console.log(`$&#123;person.name&#125; is $&#123;person.age&#125; years old`);</span><br><span class="line">observe(print);</span><br><span class="line">person.name = &quot;Joway&quot;;</span><br></pre></td></tr></table></figure>

<h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><ul>
<li>定义：对一类具有共同特征的事物的抽象(构造函数语法糖)</li>
<li>原理：类本身指向构造函数，所有方法定义在 prototype 上，可看作构造函数的另一种写法(Class &#x3D;&#x3D;&#x3D; Class.prototype.constructor)</li>
<li>方法和关键字<ul>
<li>constructor()：构造函数，new 命令生成实例时自动调用</li>
<li>extends：继承父类</li>
<li>super：新建父类的 this</li>
<li>static：定义静态属性方法</li>
<li>get：取值函数，拦截属性的取值行为</li>
<li>set：存值函数，拦截属性的存值行为</li>
</ul>
</li>
<li>属性<ul>
<li>__proto__：构造函数的继承(总是指向父类)</li>
<li>__proto__.__proto__：子类的原型的原型，即父类的原型(总是指向父类的__proto__)</li>
<li>prototype.__proto__：属性方法的继承(总是指向父类的 prototype)</li>
</ul>
</li>
<li>静态属性：定义类完成后赋值属性，该属性不会被实例继承，只能通过类来调用</li>
<li>静态方法：使用 static 定义方法，该方法不会被实例继承，只能通过类来调用(方法中的 this 指向类，而不是实例)</li>
<li>继承<ul>
<li>实质<ul>
<li>ES5 实质：先创造子类实例的 this，再将父类的属性方法添加到 this 上(Parent.apply(this))</li>
<li>ES6 实质：先将父类实例的属性方法加到 this 上(调用 super())，再用子类构造函数修改 this</li>
</ul>
</li>
<li>super<ul>
<li>作为函数调用：只能在构造函数中调用 super()，内部 this 指向继承的当前子类(super()调用后才可在构造函数中使用 this)</li>
<li>作为对象调用：在普通方法中指向父类的原型对象，在静态方法中指向父类</li>
</ul>
</li>
<li>显示定义：使用 constructor() { super(); }定义继承父类，没有书写则显示定义</li>
<li>子类继承父类：子类使用父类的属性方法时，必须在构造函数中调用 super()，否则得不到父类的 this<ul>
<li>父类静态属性方法可被子类继承</li>
<li>子类继承父类后，可从 super 上调用父类静态属性方法</li>
</ul>
</li>
</ul>
</li>
<li>实例：类相当于实例的原型，所有在类中定义的属性方法都会被实例继承<ul>
<li>显式指定属性方法：使用 this 指定到自身上(使用 Class.hasOwnProperty()可检测到)</li>
<li>隐式指定属性方法：直接声明定义在对象原型上(使用 Class.<strong>proto</strong>.hasOwnProperty()可检测到)</li>
</ul>
</li>
<li>表达式<ul>
<li>类表达式：const Class &#x3D; class {}</li>
<li>name 属性：返回紧跟 class 后的类名</li>
<li>属性表达式：[prop]</li>
<li>Generator 方法：* mothod() {}</li>
<li>Async 方法：async mothod() {}</li>
</ul>
</li>
<li>this 指向：解构实例属性或方法时会报错<ul>
<li>绑定 this：this.mothod &#x3D; this.mothod.bind(this)</li>
<li>箭头函数：this.mothod &#x3D; () &#x3D;&gt; this.mothod()</li>
</ul>
</li>
<li>属性定义位置<ul>
<li>定义在构造函数中并使用 this 指向</li>
<li>定义在类最顶层</li>
</ul>
</li>
<li>new.target：确定构造函数是如何调用</li>
</ul>
<blockquote>
<p>原生构造函数</p>
<ul>
<li>String()</li>
<li>Number()</li>
<li>Boolean()</li>
<li>Object()</li>
<li>Function()</li>
<li>Date()</li>
<li>RegExp()</li>
<li>Error()</li>
</ul>
</blockquote>
<blockquote>
<p>重难点</p>
<ul>
<li>在实例上调用方法，实质是调用原型上的方法</li>
<li>Object.assign()可方便地一次向类添加多个方法(Object.assign(Class.prototype, { … }))</li>
<li>类内部所有定义的方法是不可枚举的(non-enumerable)</li>
<li>构造函数默认返回实例对象(this)，可指定返回另一个对象</li>
<li>取值函数和存值函数设置在属性的 Descriptor 对象上</li>
<li>类不存在变量提升</li>
<li>利用 new.target &#x3D;&#x3D;&#x3D; Class 写出不能独立使用必须继承后才能使用的类</li>
<li>子类继承父类后，this 指向子类实例，通过 super 对某个属性赋值，赋值的属性会变成子类实例的属性</li>
<li>使用 super 时，必须显式指定是作为函数还是作为对象使用</li>
<li>extends 不仅可继承类还可继承原生的构造函数</li>
</ul>
</blockquote>
<blockquote>
<p><strong>私有属性方法</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const name = Symbol(&quot;name&quot;);</span><br><span class="line">const print = Symbol(&quot;print&quot;);</span><br><span class="line">class Person &#123;</span><br><span class="line">    constructor(age) &#123;</span><br><span class="line">        this[name] = &quot;Bruce&quot;;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    [print]() &#123;</span><br><span class="line">        console.log(`$&#123;this[name]&#125; is $&#123;this.age&#125; years old`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>继续混合类</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function CopyProperties(target, source) &#123;</span><br><span class="line">    for (const key of Reflect.ownKeys(source)) &#123;</span><br><span class="line">        if (key !== &quot;constructor&quot; &amp;&amp; key !== &quot;prototype&quot; &amp;&amp; key !== &quot;name&quot;) &#123;</span><br><span class="line">            const desc = Object.getOwnPropertyDescriptor(source, key);</span><br><span class="line">            Object.defineProperty(target, key, desc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function MixClass(...mixins) &#123;</span><br><span class="line">    class Mix &#123;</span><br><span class="line">        constructor() &#123;</span><br><span class="line">            for (const mixin of mixins) &#123;</span><br><span class="line">                CopyProperties(this, new mixin());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (const mixin of mixins) &#123;</span><br><span class="line">        CopyProperties(Mix, mixin);</span><br><span class="line">        CopyProperties(Mix.prototype, mixin.prototype);</span><br><span class="line">    &#125;</span><br><span class="line">    return Mix;</span><br><span class="line">&#125;</span><br><span class="line">class Student extends MixClass(Person, Kid) &#123;&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/tongju.github.io/2022/10/28/js%E5%9F%BA%E7%A1%80-es6%E7%9B%B8%E5%85%B3/" rel="prev" title="ES6相关">
      <i class="fa fa-chevron-left"></i> ES6相关
    </a></div>
      <div class="post-nav-item">
    <a href="/tongju.github.io/2022/10/29/js%E5%9F%BA%E7%A1%80-es6%E7%9B%B8%E5%85%B3%EF%BC%88%E4%B8%89%EF%BC%89/" rel="next" title="ES6相关（三）">
      ES6相关（三） <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#es6-%E7%9B%B8%E5%85%B3%E7%89%B9%E6%80%A7-%EF%BC%88%E4%BA%8C%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">es6 相关特性 （二）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ES2015"><span class="nav-number">1.1.</span> <span class="nav-text">ES2015</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Symbol"><span class="nav-number">1.1.1.</span> <span class="nav-text">Symbol</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set"><span class="nav-number">1.1.2.</span> <span class="nav-text">Set</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Set-1"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">Set</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WeakSet"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">WeakSet</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map"><span class="nav-number">1.1.3.</span> <span class="nav-text">Map</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Map-1"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">Map</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WeakMap"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">WeakMap</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Proxy"><span class="nav-number">1.1.4.</span> <span class="nav-text">Proxy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reflect"><span class="nav-number">1.1.5.</span> <span class="nav-text">Reflect</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Class"><span class="nav-number">1.1.6.</span> <span class="nav-text">Class</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">墨白</p>
  <div class="site-description" itemprop="description">个人技术成长之路</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/tongju.github.io/archives">
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/tongju.github.io/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">墨白</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script color='' opacity='' zIndex='' count='' src="/tongju.github.io/lib/canvas-nest/canvas-nest-nomobile.min.js"></script>
  <script src="/tongju.github.io/lib/anime.min.js"></script>
  <script src="/tongju.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/tongju.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/tongju.github.io/js/utils.js"></script>

<script src="/tongju.github.io/js/motion.js"></script>


<script src="/tongju.github.io/js/schemes/pisces.js"></script>


<script src="/tongju.github.io/js/next-boot.js"></script>




  















  

  


</body>
</html>
